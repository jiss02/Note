# 61강

## 값으로서 함수와 콜백: 함수의 용도 1

### 값으로서의 함수?

값이라는 것은 어떤 변수에 담을 수 있다. 함수가 일종의 값이라는 것은 변수에 담을 수 있는 속성을 가진다는 걸 의미한다.

자바스크립트의 함수가 독특한 것은, **함수가 값이 될 수 있다는 점**이다.

`function a(){}` 라고 했을 때 a라는 변수에 함수를 담은 것과 같은 의미가 된다.

`var a = function (){}` 와 동일하다.

```javascript
a = {
	b: function(){
	}
};
``` 
함수는 값이므로 객체안에 저장될 수 있다. a 객체 안에서 b는 하나의 변수 역할을 하기도한다. 키가 변수와 같은 역할을 하는 것. 

객체안에서 **변수의 역할을 하는 것을 속성, property** 라고 한다. 이러한 맥락에서 함수를 **메소드**라고 부른다. 객체 a에는 속성 b를 가지고 있고 b에 담긴 함수는 메소드이다 (객체 안에 정의된 함수가 메소드).

__함수는 값이기 때문에 다른 함수의 인자로 전달 될 수도 있다.__

```
function cal(func, num){
	return func(num)
}

function uncrease(num){
	return num - 1
}
```

함수 cal에서 func로 전달된 함수를 호출하면서 두번째 인자로 전달된 값을 첫번째 인자로 전달된 함수의 인자로 넣어주겠다는 것.

> 함수는 값이니 다른 함수의 인자로 사용될 수 있다.

# 62강

## 함수의 용도 2

함수는 리턴값으로 사용될 수도 있다. 

```
function cal(mode){
	'plus':function(l, r){return l+r;}
}

alert(cal('plus')(2,1)); // 3 출력
```

배열의 값으로도 사용가능하다.

```
var process = [
	function(input){return input + 10;},
	function(input){return input * input;}
];

var input = 1;
for(var i = 0; i < progress.length; i++){
	input = process[i](input);
}

document.write(input);
```

### first class citizen(object)

함수는 변수, 매개변수, 리턴값으로 사용될 수 있다. 이런 함수를 first class citizen(object) 라고 부르는데, 이는 **다양한 용도의 형태로 사용될 수 있음**을 의미한다.

# 63강

## 콜백

어떠한 함수가 수신하는 인자가 함수인 경우를 콜백이라고 한다.

__객체__

잠시 객체에 대해 짚어보자

```
var number = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
number.sort();
```
위와같은 코드에서 `.`앞에 있는 `number`는 **배열 객체**가 된다.
 사용자가 배열을 작성해서 제출하면 자바스크립트가 이를 읽어서 배열객체로 바꿔서 변수에 담아주는 것이다. 그래서 sort()와 같은 메소드를 사용할 수 있게 되는 것이다.

__sort__

```javascript
function sortNumber(a,b){
    // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
    return b-a;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]
```

여기서 sort 함수의 인자로 들어가는 sortNumber 함수는 콜백 함수가 된다. 

콜백함수의 내용을 인자로 전달받아 내부적으로 호출하는 것을 통해 sort의 동작을 변경하는것을 알 수 있다. 

이러한 콜백은 자바스크립트에서 함수를 값으로 취급하기때문에 사용할 수 있는 것이다. 

> 양수(꼭 1이 아니라 0 보다 큰 값)면 a를 b보다 높은 순서에, 음수(0보다 작은 값)면 b를 a보다 높은 순서에, 0이면 무시하고 다른 값들 비교... 이렇게 된다. 
 
# 64강 

## 비동기 콜백

할 일을 적어놓고 하나의 일이 끝나면 미리 등록한 작업을 실행한다.

비동기적 처리는 자바스크립트에서 어느 경우에 쓸수있느냐. Ajax 기법을 사용하면 된다. 

> Asynchronous Javascript and Xml

서버와 웹브라우저가 조용히 통신하는 것이다. ajax는 웹이 단순히 문서에서 벗어나 여러 기능을 제공하게 해주었다.

웹브라우저가 서버에 정보를 요청하면 서버가 전달하며 웹페이지를 다운받지 않아도 사용자에게 정보를 보여줄 수 있다. 

> 알림 버튼을 누르면 작게 알림창이 뜬다. 이는 새로고침이나 새로운 페이지로 넘어간 것이 아니다.

비동기적 통신을 통해 내부에서 웹브라우저와 서버가 통신을 할 수 있고, 사용자는 다른 기능을 이용할 수있다. 만약 동기적 처리라면 사용자가 어떤 정보를 요청했을 때, 그정보가 도착해서 보여질때 까지 아무것도 하지 못하는 것이다.

### 예제

```javascript
<script type="text/javascript">
    $.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
</script>
```

get은 url로 전달된 파일을 읽은뒤에, 두번째 인자인 function을 호출하게 되어있다. 또 콜백함수에 인자를 넘겨주기로 약속이 되어있는데, 이는 서버에서 가져온 정보에 해당한다.

get이라는 함수가 서버에서 정보를 가져오는 로직은 고정되어있다. 그러나 그 데이터를 가져와서 어떻게 처리할지는 다양하므로, 처리방법을 사용자에게 위임을 한다. 위임을 하는 기법이 바로 콜백함수이며, 이를 통해 get 메소드는 함수를 인자로 전달받는 것이다.

사용자는 함수를 인자로 전달함으로써 get 메소드가 전달하는 방법을 제어할 수 있는 것이다.

__정리__

url에 해당하는 데이터를 get이라는 메소드가 읽어서 읽은 결과를 해석한 후에 함수를 호출하며 인자로 넘겨준다. 이 값을 받아 리스트를 만들거나 웹페이지를 만들거나 하는 것이다.

# 65강

## 클로저: 외부함수와 내부함수

__클로저란?__

내부함수가 외부함수의 맥락에 접근할 수 있는 것. 말이 너무 어렵다.. 

### 외부함수와 내부함수

내부함수: 함수안에 함수가 존재하는 것.

```javascript
function outter(){
    function inner(){
        var title = 'coding everybody'; 
        alert(title);
    }
    inner();
}
outter();

```

함수 안에서만 사용되는 함수가 있다고 했을 때, 이를 밖에다 선언하면 편집성이 줄어든다. 이런 문제를 방지하기위해 외부함수와 내부함수의 개념을 사용하는 것이다.

__장점__

외부함수에 정의된 지역변수를 내부함수에서 사용할 수 있다.

# 66강 

## 클로저란?

외부함수가 더이상 사용되지 않아도 내부함수가 외부함수의 변수에 접근할 수 있다!

```
function outter(){
	var title = 'coding everybody';
	return function(){
		alert(title);
	}
} 

inner = outter();
inner();
```

위와같이 내부함수를 return값 으로 줄 수 있다. 리턴으로 전달된 내부함수를 호출했을 때, outter 함수는 수명이 끝났음에도 불구하고 외부함수의 title에 대한 접근을 하는 것임.

내부함수를 포함하는 외부함수에 접근할 수 있으면서도, 외부함수가 종료되어도 내부함수로 접근할 수 있다는 것이 클로저의 매력적인 포인트.

# 67강

## private varible

비밀 변수.

소프트웨어가 커지는 과정에서 어떠한 정보를 아무나 수정하는 것을 방지하는 것.

객체 안에 함수가 정의된 모양. 객체안에 정의된 함수들이 내부함수가 되는 것이다. 내부함수를 내포하는 외부함수의 지역변수에 접근할 수 있다.

```
fuction movie(title){
	return {
		get_title : function (){
			return title;
		},
		set_title : function (_title){
			title=_title;
		}
	}
}
```

return값으로 객체를 리턴한다. 이객체는 두개의 속성을 가진다. 그 값은 함수이다. (겟타이틀, 셋타이틀)

이때, title은 get_title과 set_title로만 접근할 수 있는 변수가 되는 것이다. 이럴때 어떤 장점이 생기는가?

객체안에 함수가 정의된 형국으로 객체안에 담긴 함수를 내부함수라고 보면된다. 객체에 소속된 점이라는 것만 다를 뿐이다.

내부함수를 생성하는 외부함수의 지역변수에 접근할 수 있다.

title 이라는 변수를 아무나 사용할 수 없어 안정성이 높아진다. 다른 사람이 title이라는 변수를 써도 함수내부의 title에는 변화가 없기 때문이다.

이럴 때 title 이 private 변수인데, set에의해서만 변경할 수 있고, get에 대해서만 title변수를 가져올 수 있다.

# 68강

## 클로저의 응용

```
var arr = []
for(var i=0;1<5;i++){
	arr[i] = function(){
	console.log(i);
	// return i 를 해도 결과는 같다.
	}
}
```

위의 코드를 실행하면 5가 5번 나온다. i의 상태가 저장되는게 아니라 i를 찍어내는 그 자체의 행위만 담긴 것이기 때문.

이를 방지하고 싶다면 다른 방식의 코드를 사용해야하는데, i의 값이 우리가 정의한 함수의 외부변수의 값이 아니기 때문에 원하는 상황이 나오지 않은 것이란걸 알자.

```
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}
```

위와같이 변경해야한다. id라는 매개변수의 값으로 i값을 받아 함수내부로 전달하고 전달과 동시에 내부함수를 리턴하고 있다. 

내부함수가 외부함수의 지역변수에 접근할 수 있었기 때문이고, 함수가 만들어지는 시점에서의 i값을 외부함수가 id 라는 지역변수로 갖고있었기 때문에 그 외부함수의 내부함수를 호출하면 그 지역변수의 id값을 호출하게 된다.

# 69강

## arguments란?

arguments라는 객체는 함수안에서 함수의 여러가지 정보를 가지고 있다. 특히, 인자에 대한 정보를 담고있는데 배열과 비슷하여 유사 배열이라 부른다.

```
function sum(){
    var i, _sum = 0;    
    for(i = 0; i < arguments.length; i++){
        document.write(i+' : '+arguments[i]+'<br />');
        _sum += arguments[i];
    }   
    return _sum;
}
document.write('result : ' + sum(1,2,3,4));
```

js는 인자가 몇개든 에러를 발생시키지는 않는다. 아주 친절하다. 

> 매개변수보다 인자를 더 많이준다고 하더라도 오류를 내지 않는다.

arguments는 하나의 약속된 특수한 이름의 변수명이며 arguments라는 유사객체가 들어있다. 사용자가 전달한 인자가 이 안에 들어가게 된다.  

사용자가 전달하는 인자의 수만큼을 담는다. 

sum은 인자를 받지 않는데, 우리는 몇개의 인자가 들어올지 모르니 arguments라는 약속된 이름을 통해 사용자가 전달해준 인자에 접근한다.


# 70강

## function length

__매개변수의 수__

`arguments.length`를 통해 몇개의 인자가 들어왔는지 알수있다. 그러나 함수를 정의할때 몇개의 인자를 정의했는 지는 알 수 없다. 

함수.length = 함수가 정의한 매개변수의 수를 알려준다.

arguments.length = 함수가 실제로 호출될때 몇개의 인자를 전달받았는지에 대한 정보를 가지고 있다. 

```
function two(arg1, arg2){
	console.log(
		'two.length', two.length, 'arguments', arguments.length);
}

two('haha);
// two.length = 2
// arguments.length = 1
```







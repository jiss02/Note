# 41강 

## 모듈

코드가 크고 복잡해질수록 재활용성을 높이고 유지보수를 쉽게 하기위해 여러 기법들이 사용된다.

프로그램을 구성하는 로직들을 조각조각 나눠 구역화를 시켜 모듈이라는 형태로 분리한다. 마치 하나의 부품처럼 사용하는 것이다. 이를 모듈화라고 한다.

### 모듈화의 방법

코드를 여러개의 파일로 분리한다.

__장점__

- 필요할때마다 해당 코드파일 재사용이 가능하다.
- 연관된 함수나 변수들을 파일로 모아놓으니 재사용성이 높아진다.
- 필요한 로직을 빠르게 찾을 수 있다
- 필요한 로직만을 로드해서 메모리의 낭비를 줄일 수 있다. 각각의 필요한 파일들이 다 쪼개져 있으니 필요한것만 불러오면 되기 때문이다.
- 웹브라우저를 통해 js를 이용할때, 한번 다운 된 모듈은 브라우저에의해 저장되고, 네트워크 트레픽감소를 시킬 수 있다. 사용자의 입장에서는 빠르게 로드되니 서로 윈윈인 것!

js자체에서는 모듈이라는 개념이 자세하게 존재하지않는다. 하지만 js가 돌아가는 환경(호스트환경=노드나 웹브라우저)에 따라서 js로직을 파일로 분할하여 마치 다른 프로그래밍언어의 모듈처럼 사용할 수 있다.

# 42강

## 모듈화

> 밑의 예제는 개념을 잡기위해 간단하게 작성한 코드임을 인지하자.

__모듈없는 애플리케이션__

```
<script>
	function welcome(){
		return 'hello';
	}
	alert(welcome());	
</script>
```

웰컴함수가 매우 복잡한 코드라고 해보자. 그렇다면 html전체 코드가 매우 비대해질 것이다. 

따라서 welcome함수를 지우고 다른 js를 파일을 만들어 해당 함수코드를 넣는다.

그리고, head 태그안에 

`<script type="text/javascript" src="welcome.js"></script>`코드를 넣어 따로 불러온다.

> src속성을 확인하여 불러올 파일이 있다면, 그 파일을 불러와 script태그 안에 넣는 것과 동일한 효과를 준다.

파일의 관심사가 아닌 것을 별도의 파일로 분류해놓고 필요할 때 호출하면 코드의 가독성이 획기적으로 좋아진다!

지금까지 웹브라우저에서 어떤식으로 모듈처럼 다루는지를 살펴보았다.

# 43강

## Node.js의 모듈화

노드에서는 호스트 환경중 하나이다. 모듈을 로드하는 방법이 달라진다.

```
var x = require('./welcome.js');
```

require이라는 함수를 이용해서 모듈을 불러와야한다.

# 44강

## 모듈: 라이브러리란?

모듈은 작은 부품이라는 것에 초점이 맞춰짐. 라이브러리는 재사용하기 편하도록 잘 정리한 일련의 코드들의 집합을 의미한다고 할 수 있다. 필요한 라이브러리를 잘 선택하고 응용하는 능력을 갖는 것은 매우 중요하다.

서버와 쉽게 통신한다거나, 브라우저를 쉽게 제어한다거나 하는 목적을 정해놓고 사용하는 것이 좋다. 라이브러리가 매우 많고 파편화되어있기때문이다.

유행하는 라이브러리는 언제든 바뀔 수 있기때문에 잘 살펴보도록 하자.

__API__

환경에서 제공하는 명령어를 통해 애플리케이션의 기능을 제어하는데, 이를 API라고 한다.

위의 코드에서 welcome.js라는 파일이 welcome이라는 기능을 제공하므로 이는 하나의 API가 되는 것이며 이 함수가 무슨일을 하는지 문서화하여 공유하면 API 문서가 된다.

> API 설명서를 보고 제공하는 명령어를 파악하여 API를 사용하게 되는 것

# 47강

## UI와 API와 그리고 문서

### UI

컴퓨터 시스템과 사용자 사이에 존재하면서, 사람이 생각하는 바를 전달하는 입력장치 그리고 계산 결과등을 알려주는 출력장치와 같은 중개역할을 하는 것들이 유저인터페이스이다. 사용자와 대면하는 것. 그것이 UI이다. 

> 웹페이지의 버튼같은 것들 

### API

> application programming interface

UI라고 하기는 뭐한, 사용자들이 잘 사용하지 않는 인터페이스를 의미한다. 버튼이나 스크롤바와는 다른 그런 종류의 것을 의미한다.

예를 들면 `alert('hello');` 명령이 있다. 브라우저에 명령을 전달해서 알람창을 뜨게하므로 일종의 인터페이스지만, 사용자들이 쓰는 버튼과 형식이 아닌 코드의 형태를 띈 인터페이스인 것이다. 이런 코드들을 다양하게 조합해서 애플리케이션을 만들고 제어하는 것이 API이다.

> 사용자는 버튼(UI)을 통해 시스템 제어를 한다. 그러나 개발자들은 API를 맥락에 맞게 응용하며 애플리케이션을 제어하는 것이다.

### 인터페이스

위층과 아래층의 접점이 되는 부분이다.

### 인터페이스의 계층

우리는 웹브라우저가 제공하는 API를 통해 기능을 제어한다. 하지만 그 밑단에는 계층이 더 존재한다. 운영체제 위에서 웹브라우저가 돌아가므로, 운영체제 별로 제공하는 인터페이스에 따라 웹브라우저가 실행되는 것이다. 

즉, 운영체제가 플랫폼이되고 운영체제가 제공하는 인터페이스에 따라 그 위에서 웹브라우저가 돈다. 뿐만아니라 웹브라우저가 플랫폼이 되고, 웹브라우저가 제공하는 API에 따라 개발자가 기능을 제어하는 것이다.

사용자는 UI를 통해 시스템을 제어한다.

개발자는 UI 접점 밑에서 시스템을 구축하고, 사용자들이 UI를 통해 제어할 수 있도록 한다.

... 이런식으로 밑단으로 내려가보면,

사용자 - 웹개발자 - 웹브라우저 개발자 - 운영체제 - 운영체제를 만들기위한 언어들 - 어셈블리어 - 기계어 순으로 내려가게 된다.

밑단에 있는 것은 위층에게 인프라를 제공하는 것이고, 위층에 있는 것은 아래층에 있는 것들을 응용하여 사용하는 것이다.

# 48강

## UI와 API문서

환경을 조작하기 위해서는 환경이 제공하는 일종의 조작장치인 api를 통해 소프트웨어를 제어하게된다.

프로그래밍을 만든다는 것은, 프로그램이 제어하고자 하는 환경이 어떤 api를 가지고 어떤 특성이 있고 이를 어떻게 사용하는지를 알고 있어야한다.

그러나 수많은 api를 알고있는 것은 어려우므로, 문서를 잘 찾아 환경이 어떤 기능을 제공하는지 아는 것이 중요하다.

### 튜토리얼과 레퍼런스

튜토리얼은 하나의 안내서이며 문법을 설명하는 정도로 보면된다.

래퍼런스는 제공하는 명령어들이라고 보면 이해가 쉬울 것이다. 


### JS의 API

- 자바스크립트 자체 api
	- math 같은 수학적 계산
	- 정규표현식 등
- 호스트 환경의 api
	- 웹브라우저
	- 노드js

# 49강

## 정규표현식

정규표현식은 하나의 개별적인 언어이다. 정규표현식은 다른 수많은 언어에서도 사용된다. 이제 자바스크립트 내에서 정규표현식을 조작하는 방법을 알아보자.

문자열에서 어떤 문자열이 있는지 없는지 또는 어떤 패턴을 찾아 다른 문자열로 치환할 지에 대한 일을 하는 것이다.

# 50강

## 정규표현식: 패턴만들기

1. 컴파일: 어떠한 작업을 하기위해 필요한 대상을 찾는 것. 패턴을 찾는 것.
2. 실행: 찾은 대상에 대해서 어떤 구체적 작업을 할 것인지.

### 정규표현식 선언

1. 정규표현식 리터럴

정규표현식 리터럴을 사용하여 찾고자하는 문자를 위치시키면 된다.

`var pattern = /a/;`

우리가 찾고자 하는 것은 문자 a 가 되는 것이다.

2. 정규표현식 객체 생성자

객체를 통해 정규표현식을 생성한다. 

`var pattern = new RegExp('a');`

new를 통해 정규표현식 객체를 생성한다. 문자열 a를 찾고자 하는 것이다. 

> Regular expression의 약자

# 51강

## RegExp 객체의 정규 표현식

__50강의 큰 요약__

1. 작업대상찾기
2. 대상에 대해 어떤 작업을 하는 것

정규표현식 문법에 맞게 긴 패턴을 찾아내는 능력을 기르자. 

원하는 정보의 추출과 자신이 확인하는 정보가 있는지 테스트하는 것, 검색된 정보를 다른 정보로 치환하는 것이 주 사용범위다.

### 정규표현식 함수

`pattern.exec('검색할대상');`

배열이 리턴된다. 정규표현식을 실행할 것인데, 실행의 대상을 첫번째 인자로 전달한다. 만약 찾고자하는 대상(패턴)이 존재하지 않는다면 null값을 리턴한다.

즉, 찾고자 하는 패턴이 대상안에 있다면 배열로 반환해주는 역할을 하는 것이다.

> 필요한 정보를 추출하는 것이 exec의 목표이다.

__"."__

하나의 문자를 의미한다. `a.` 이라하면, a뒤에 반드시 문자하나가 있어야 한다는 것이다. 

`pattern.test('대상');`

리턴값이 boolean이다. 대상안에 찾는 패턴이 존재하면 true를, 없으면 flase를 반환한다.

> 존재유무를 테스트 하는 것이 test이다.

# 52강

## string 객체의 정규표현식

문자열에서 메소드를 사용하는 방법을 살펴보자.

```
string.match("pattern")
```

pattern.exec();와 같은 역할을 한다.

```
str.replace("pattern", "치환할 문자열");
```

패턴에 해당하는 문자를 다른 문자열로 치환하는 기능을 한다.

# 53강

## 정규표현식: 옵션

정규표현식에는 옵션이라는 것이 있고, 이를 통해 정규표현식을 좀 다르게 사용할 수 있다.

__i__

`i`를 붙이면 대소문자를 구분하지 않는다.

`var patter = /a/i;`

뒤에 i를 넣어주면 된다. 

__g__

검색된 모든 결과를 리턴한다. "abca"인 상태에서 "a"를 찾는다고 했을 때, g를 붙이면 ["a","a"] 와 같이 a가 두번나온다.

> i와 g를 함께 사용할 수도 있다.

# 54강

## 정규표현식: 캡쳐

__정규표현식에서__

`()`는 그룹을 의미한다. 

`\w`는 모든 문자를 의미한다. 

> 알파벳 소문자 a부터 대문자Z 까지, 0~9까지

`+`는 문자가 하나 이상이라는 의미이다.

ex. (\w+): a-Z,0-9까지의 문자중 하나 이상이면 OK!

`\s`는 공백을 의미한다.

__예제__

```javascript
var pattern = (\w+)\s(\w+);
var str = "coding everybody";
var result = str.replace(pattern, "$2, $1");

console.log(result);
```

==> everybody, coding이 로그에 찍힌다.

여기서 $ 기호는 특수한 의미를 갖는데, 그룹을 의미한다. 그룹을 지정해서 그룹의 값을 이용하여 위치를 바꾸거나 하는 그런 기능을 캡쳐라고한다.

(\w+)가 하나의 그룹이므로, `(\w+)\s(\w+)`에서는 그룹이 두개라고 볼 수 있다.

# 55강

## 정규표현식: 치환

...

# 56강 

## 유효범위: 전역변수와 지역변수

유효범위는 변수의 수명을 의미한다. 

```
var vscope = 'global' // 전역변수;
funciton fscope(){
	alert(vscope);
}
```

fscope안에 선언되지 않은, 바깥쪽에 선언된 vscope을 사용한다. global이 출력될 것이다.

```
var vscope = 'global';
funciton fscope(){
	var vscope = 'local' // 지역변수;
	alert(vscope);
}
```

이런 코드의 경우, fscope내에 정의된 vscope을 사용하여 local이 출력될 것이다. 즉 변수를 사용할 때, 함수 내부에서 정의된 것이 있는지 먼저 탐색하고, 내부에 없다면 바깥쪽으로 넘어가 찾는것이다.

__지역변수__

함수의 중괄호 안쪽에서만 접근이 가능한 변수. 함수안에서만 접근 가능하다. 정의된 함수를 벗어나면 사용할 수 없다. 

__전역변수__

자바스크립트 애플리케이션 전역에서 접근할 수 있는 변수. 어느 함수에도 소속되지 않은 변수이다. 사용을 지양하도록 하자

> 함수에서 변수를 사용할때 내부에 지역변수가 있는지보고, 지역변수가 있으면 이를 우선적으로 사용한다. 

함수 안에서만 의미있는, 함수안에서만 존재할 수 있는 지역변수를 선택하는 것이 중요하다. 같은 이름의 변수를 사용할 일이 발생할 수도 있고, 프로그램이 점점 크고 복잡해질수록 전역변수를 사용하면 문제가 발생할 수 있기 때문이다.

# 57강

## 유효범위의 효용

여러개의 반복문을 사용할 때, 같은 이름의 변수를 사용한다면   변수의 증감이 꼬여 무한루프에 빠질 수도 있다. 이런 문제를 해결해주는게 지역변수다.

지역변수를 하나의 디렉토리에서 사용하는 것이라 상상해보자. 디렉토리 안에서는 같은 이름을 사용하면 안되지만, 다른 디렉토리끼리는 다른 이름을 사용해도 되도록하는 것이 지역변수라 이해하면 좋을 것이다.

# 58강

## 전역변수를 사용하는 방법

불가피하게 전역변수를 사용해야하는 경우 어떻게 해야할까?

객체에 속성을 주어 사용하자. (객체안에 있는 변수를 속성이라고 한다.)

```javascript
var app = {} // 객체생성

app.calculation = {
	'left' : null,
	'right': null
}

app.coordinate = {
	'left' : null,
	'right': null
}
```

# 59강

## 유효범위의 대상

자바스크립트는 함수에 대한 유효범위만을 제공한다.

> 다른 언어는 `{}` 으로 구분하는 경우가 많다.

__ex__

```javascript
for(;;){
	var name = 'sam'; // 전역변수
}
```

```java
for(;;){
	String name = 'sam'; // 지역변수
}
```

# 60강

## 정적 유효 범위

자바스크립트는 함수가 선언된 시점에서 유효범위를 갖는다. 이러한 유효범위의 방식을 정적유효범위 혹은 렉시컬이라고 한다.

이는 클로저라는 개념과 연결되므로 잘 기억해 두자.

```javascript
var i = 5;

function a(){
	var i = 10;
	b();
}

function b(){
	document.write(i);
}

a();

```

위와같은 코드가 있을 때, 어떤 i를 사용할까?

답은 전역변수 i(값: 5)를 사용한다. 함수 b가 정의된 시점에서 전역변수 i를 사용하기 때문이다. 함수 b는 누구에게 사용될지 모르고 사용되는 대상에 따라 해당 변수에 접근할 수 있다면 그것은 동적 유효범위가 된다. 그러나 만약 정의되는 시점에서 변수를 바라보게 된다면 누가사용하던 같은 결과를 얻게 되므로 이는 정적유효범위하고 한다.

사용될 때가 아닌 정의될 때를 기준으로 변수를 선택하는 것이다! 이런 것을 정적유효범위, 렉시컬이라고 한다. 

# 61강

## 값으로서 함수와 콜백: 함수의 용도 1

### 값으로서의 함수?

값이라는 것은 어떤 변수에 담을 수 있다. 함수가 일종의 값이라는 것은 변수에 담을 수 있는 속성을 가진다는 걸 의미한다.

자바스크립트의 함수가 독특한 것은, **함수가 값이 될 수 있다는 점**이다.

`function a(){}` 라고 했을 때 a라는 변수에 함수를 담은 것과 같은 의미가 된다.

`var a = function (){}` 와 동일하다.

```javascript
a = {
	b: function(){
	}
};
```

함수는 값이므로 객체안에 저장될 수 있다. a 객체 안에서 b는 하나의 변수 역할을 하기도한다. 키가 변수와 같은 역할을 하는 것. 

객체안에서 **변수의 역할을 하는 것을 속성, property** 라고 한다. 이러한 맥락에서 함수를 **메소드**라고 부른다. 객체 a에는 속성 b를 가지고 있고 b에 담긴 함수는 메소드이다 (객체 안에 정의된 함수가 메소드).

__함수는 값이기 때문에 다른 함수의 인자로 전달 될 수도 있다.__

```
function cal(func, num){
	return func(num)
}

function uncrease(num){
	return num - 1
}
```

함수 cal에서 func로 전달된 함수를 호출하면서 두번째 인자로 전달된 값을 첫번째 인자로 전달된 함수의 인자로 넣어주겠다는 것.

> 함수는 값이니 다른 함수의 인자로 사용될 수 있다.

# 62강

## 함수의 용도 2

함수는 리턴값으로 사용될 수도 있다. 

```
function cal(mode){
	'plus':function(l, r){return l+r;}
}

alert(cal('plus')(2,1)); // 3 출력
```

배열의 값으로도 사용가능하다.

```
var process = [
	function(input){return input + 10;},
	function(input){return input * input;}
];

var input = 1;
for(var i = 0; i < progress.length; i++){
	input = process[i](input);
}

document.write(input);
```

### first class citizen(object)

함수는 변수, 매개변수, 리턴값으로 사용될 수 있다. 이런 함수를 first class citizen(object) 라고 부르는데, 이는 **다양한 용도의 형태로 사용될 수 있음**을 의미한다.

# 63강

## 콜백

어떠한 함수가 수신하는 인자가 함수인 경우를 콜백이라고 한다.

__객체__

잠시 객체에 대해 짚어보자

```
var number = [20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];
number.sort();
```

위와같은 코드에서 `.`앞에 있는 `number`는 **배열 객체**가 된다.
 사용자가 배열을 작성해서 제출하면 자바스크립트가 이를 읽어서 배열객체로 바꿔서 변수에 담아주는 것이다. 그래서 sort()와 같은 메소드를 사용할 수 있게 되는 것이다.

__sort__

```javascript
function sortNumber(a,b){
    // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
    return b-a;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]
```

여기서 sort 함수의 인자로 들어가는 sortNumber 함수는 콜백 함수가 된다. 

콜백함수의 내용을 인자로 전달받아 내부적으로 호출하는 것을 통해 sort의 동작을 변경하는것을 알 수 있다. 

이러한 콜백은 자바스크립트에서 함수를 값으로 취급하기때문에 사용할 수 있는 것이다. 

> 양수(꼭 1이 아니라 0 보다 큰 값)면 a를 b보다 높은 순서에, 음수(0보다 작은 값)면 b를 a보다 높은 순서에, 0이면 무시하고 다른 값들 비교... 이렇게 된다. 

# 64강 

## 비동기 콜백

할 일을 적어놓고 하나의 일이 끝나면 미리 등록한 작업을 실행한다.

비동기적 처리는 자바스크립트에서 어느 경우에 쓸수있느냐. Ajax 기법을 사용하면 된다. 

> Asynchronous Javascript and Xml

서버와 웹브라우저가 조용히 통신하는 것이다. ajax는 웹이 단순히 문서에서 벗어나 여러 기능을 제공하게 해주었다.

웹브라우저가 서버에 정보를 요청하면 서버가 전달하며 웹페이지를 다운받지 않아도 사용자에게 정보를 보여줄 수 있다. 

> 알림 버튼을 누르면 작게 알림창이 뜬다. 이는 새로고침이나 새로운 페이지로 넘어간 것이 아니다.

비동기적 통신을 통해 내부에서 웹브라우저와 서버가 통신을 할 수 있고, 사용자는 다른 기능을 이용할 수있다. 만약 동기적 처리라면 사용자가 어떤 정보를 요청했을 때, 그정보가 도착해서 보여질때 까지 아무것도 하지 못하는 것이다.

### 예제

```javascript
<script type="text/javascript">
    $.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
</script>
```

get은 url로 전달된 파일을 읽은뒤에, 두번째 인자인 function을 호출하게 되어있다. 또 콜백함수에 인자를 넘겨주기로 약속이 되어있는데, 이는 서버에서 가져온 정보에 해당한다.

get이라는 함수가 서버에서 정보를 가져오는 로직은 고정되어있다. 그러나 그 데이터를 가져와서 어떻게 처리할지는 다양하므로, 처리방법을 사용자에게 위임을 한다. 위임을 하는 기법이 바로 콜백함수이며, 이를 통해 get 메소드는 함수를 인자로 전달받는 것이다.

사용자는 함수를 인자로 전달함으로써 get 메소드가 전달하는 방법을 제어할 수 있는 것이다.

__정리__

url에 해당하는 데이터를 get이라는 메소드가 읽어서 읽은 결과를 해석한 후에 함수를 호출하며 인자로 넘겨준다. 이 값을 받아 리스트를 만들거나 웹페이지를 만들거나 하는 것이다.

# 65강

## 클로저: 외부함수와 내부함수

__클로저란?__

내부함수가 외부함수의 맥락에 접근할 수 있는 것. 말이 너무 어렵다.. 

### 외부함수와 내부함수

내부함수: 함수안에 함수가 존재하는 것.

```javascript
function outter(){
    function inner(){
        var title = 'coding everybody'; 
        alert(title);
    }
    inner();
}
outter();

```

함수 안에서만 사용되는 함수가 있다고 했을 때, 이를 밖에다 선언하면 편집성이 줄어든다. 이런 문제를 방지하기위해 외부함수와 내부함수의 개념을 사용하는 것이다.

__장점__

외부함수에 정의된 지역변수를 내부함수에서 사용할 수 있다.

# 66강 

## 클로저란?

외부함수가 더이상 사용되지 않아도 내부함수가 외부함수의 변수에 접근할 수 있다!

```
function outter(){
	var title = 'coding everybody';
	return function(){
		alert(title);
	}
} 

inner = outter();
inner();

```

위와같이 내부함수를 return값 으로 줄 수 있다. 리턴으로 전달된 내부함수를 호출했을 때, outter 함수는 수명이 끝났음에도 불구하고 외부함수의 title에 대한 접근을 하는 것임.

내부함수를 포함하는 외부함수에 접근할 수 있으면서도, 외부함수가 종료되어도 내부함수로 접근할 수 있다는 것이 클로저의 매력적인 포인트.

# 67강

## private varible

비밀 변수.

소프트웨어가 커지는 과정에서 어떠한 정보를 아무나 수정하는 것을 방지하는 것.

객체 안에 함수가 정의된 모양. 객체안에 정의된 함수들이 내부함수가 되는 것이다. 내부함수를 내포하는 외부함수의 지역변수에 접근할 수 있다.

```
fuction movie(title){
	return {
		get_title : function (){
			return title;
		},
		set_title : function (_title){
			title=_title;
		}
	}
}

```

return값으로 객체를 리턴한다. 이객체는 두개의 속성을 가진다. 그 값은 함수이다. (겟타이틀, 셋타이틀)

이때, title은 get_title과 set_title로만 접근할 수 있는 변수가 되는 것이다. 이럴때 어떤 장점이 생기는가?

객체안에 함수가 정의된 형국으로 객체안에 담긴 함수를 내부함수라고 보면된다. 객체에 소속된 점이라는 것만 다를 뿐이다.

내부함수를 생성하는 외부함수의 지역변수에 접근할 수 있다.

title 이라는 변수를 아무나 사용할 수 없어 안정성이 높아진다. 다른 사람이 title이라는 변수를 써도 함수내부의 title에는 변화가 없기 때문이다.

이럴 때 title 이 private 변수인데, set에의해서만 변경할 수 있고, get에 대해서만 title변수를 가져올 수 있다.

# 68강

## 클로저의 응용

```
var arr = []
for(var i=0;1<5;i++){
	arr[i] = function(){
	console.log(i);
	// return i 를 해도 결과는 같다.
	}
}

```

위의 코드를 실행하면 5가 5번 나온다. i의 상태가 저장되는게 아니라 i를 찍어내는 그 자체의 행위만 담긴 것이기 때문.

이를 방지하고 싶다면 다른 방식의 코드를 사용해야하는데, i의 값이 우리가 정의한 함수의 외부변수의 값이 아니기 때문에 원하는 상황이 나오지 않은 것이란걸 알자.

```
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}

```

위와같이 변경해야한다. id라는 매개변수의 값으로 i값을 받아 함수내부로 전달하고 전달과 동시에 내부함수를 리턴하고 있다. 

내부함수가 외부함수의 지역변수에 접근할 수 있었기 때문이고, 함수가 만들어지는 시점에서의 i값을 외부함수가 id 라는 지역변수로 갖고있었기 때문에 그 외부함수의 내부함수를 호출하면 그 지역변수의 id값을 호출하게 된다.

# 69강

## arguments란?

arguments라는 객체는 함수안에서 함수의 여러가지 정보를 가지고 있다. 특히, 인자에 대한 정보를 담고있는데 배열과 비슷하여 유사 배열이라 부른다.

```
function sum(){
    var i, _sum = 0;    
    for(i = 0; i < arguments.length; i++){
        document.write(i+' : '+arguments[i]+'<br />');
        _sum += arguments[i];
    }   
    return _sum;
}
document.write('result : ' + sum(1,2,3,4));

```

js는 인자가 몇개든 에러를 발생시키지는 않는다. 아주 친절하다. 

> 매개변수보다 인자를 더 많이준다고 하더라도 오류를 내지 않는다.

arguments는 하나의 약속된 특수한 이름의 변수명이며 arguments라는 유사객체가 들어있다. 사용자가 전달한 인자가 이 안에 들어가게 된다.  

사용자가 전달하는 인자의 수만큼을 담는다. 

sum은 인자를 받지 않는데, 우리는 몇개의 인자가 들어올지 모르니 arguments라는 약속된 이름을 통해 사용자가 전달해준 인자에 접근한다.

# 70강

## function length

__매개변수의 수__

`arguments.length`를 통해 몇개의 인자가 들어왔는지 알수있다. 그러나 함수를 정의할때 몇개의 인자를 정의했는 지는 알 수 없다. 

함수.length = 함수가 정의한 매개변수의 수를 알려준다.

arguments.length = 함수가 실제로 호출될때 몇개의 인자를 전달받았는지에 대한 정보를 가지고 있다. 

```
function two(arg1, arg2){
	console.log(
		'two.length', two.length, 'arguments', arguments.length);
}

two('haha);
// two.length = 2
// arguments.length = 1

```

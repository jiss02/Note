# 71강

## 함수의 호출: apply 소개

js에서 함수는 하나의 객체이다. 그리고 객체는 속성을 가진다. 이때 속성에 값이 저장되어있다면 **속성**, 그런데 함수가 들어있다면 **메소드**라고 부른다.

함수는 객체이며, 함수에는 js에서 제공하는 메소드를 사용할 수 있다.

```
func.apply
func.call
```
을 통해 함수를 호출할 수 있다.

#### apply

apply는 함수다. `func.apply`코드를 통해 함수라는 객체에 담긴 메소드라는 것을 확인할 수 있다.

내장된 코드면 native code를 띄우며 내부 코드를 보여주지 않는다.

두 값을 더하는 sum함수가 있다고 치고 예제를 보자

```
sum.apply(null, [1,2]);
```

배열안의 0번째 값이 첫번째 인자로, 1번째 값이 두번째 인자로 들어간다.

__왜 이렇게 호출하는가?__

apply의 첫번째 인자에 다른 것을 넣을 때 사용하라고 존재하는 것이다! 첫번째 값이 null값이면 딱히 사용할 이유가 없다.

# 72강

## apply의 사용

```
o1 = {var1: 1, val2: 2, val3: 3}
o2 = {v1:10, v2:50, v3:100, v4:25}

fuction sum(){
	var _sum = 0;
	for (name in this){
		_sum += this[name];
	}
	return _sum;
}

alert(sum.apply(o1))
alert(sum.apply(o2))
```

#### apply가 없다면

sum이 호출되면서 객체를 인자에 주게되고, 인자로 준 객체가 this가 된다. 암묵적으로 `var this = o1;` 이런 코드가 들어간다고 생각하면 쉽다.

```
alert(sum.apply(o1))
```

이렇게 되는 순간에, o1.sum() 이 되는 것이다. o1객체의 sum메소드가 들어간것이 되는 것이다.

```
o1 = {var1: 1, val2: 2, val3: 3, sum:sum};
alert(o1.sum());
```

하지만 이런 식을 사용하면 결과에 함수 내용도 나오게 되는 문제가 발생한다. 함수가 객체 안에 들어가면서 for문이 돌때 함께 돌기 때문이다. 이를 방지하기 위해서는 for문을 아래와 같이 고치면 된다.

```
for (name in this){
	if (typeof this[name] !== 'function'){
		_sum += this[name];
		}
	}
```

객체에 함수를 따로 추가하고 어쩌고... 이런 번거로운 과정들을 apply라는 것을 사용하여 간단하게 표현할 수 있는 것이다. 

# 73강

## 객체지향프로그래밍: OT

OOP: Object Oriented Programming

#### 객체가 도대체 무엇일까?

추상적으로, 상태와 행위로 이루어진 것이 객체이다. 객체들을 마치 이렇게 저렇게 조립해서 하나의 프로그램을 만드는 것이 OOP라고 할 수 있다.

하나의 프로그램은 여러개의 목적성을 가진 로직들의 집합이라고 볼수 있다. 작은 프로그램이라면 괜찮지만, 프로그램이 커지고 관리하는 사람이 많아질수록 코드가 복잡해지니 비슷한 로직들을 기능적으로 구분하고 정리하고 싶다는 욕구가 드는 것은 당연할 것이다. 

이런 욕구로 인해 서로 연관된 것들끼리 그룹핑을 할 방법을 모색하다가 등장한 개념 중 하나가 객체라고 생각하면 더 이해하기 쉬울 것이다.

__자세히 알아보자__

변수와 메소드를 서로 연관되어있는 것 끼리 그룹핑하는 것을 프로그래밍 언어 차원에서 제공하는 것이다. 이렇게 그룹핑된 하나하나의 단위들을 객체라고 한다.

만약 글목록이라는 기능과 연관된 변수와 메소드가 있다면, 이들끼리 객체라는 단위로 응집되어 있는 것이다. 다른 성격을 가진(연관성이 없는) 로직들과는 객체라는 껍데기로 분리되어있는 것이다.

분류하고 카테고라이징하다보니 객체라는 기능이 나타나게 된 것이다.

__요약__

객체지향프로그래밍은 객체를 만드는 것이고 객체는 구체적이고 문법적인 기능이 언어적으로 제공된다. 하나의 객체 안에는 그 객체가 가진 취지에 따라 그 취지에 연관된 변수와 메소드가 들어있다. 그리고 연관성이 없는 다른 로직과 구분짓는 선이기도 하다.

# 74강

## 객체지향프로그래밍: 추상화

두가지의 접근이 필요하다.

1. 문법적 요소
2. 설계
	- 현실에서 관심있는 어떤 특성을 sw화 시켜서 문제를 풀어나가는 것.
	- 현실은 매우 복잡하기 때문에 문제에 맞춰 필요한 부분만 잘 뽑아오는 것이 중요하다.

즉, 현실에서 우리가 가진 관심사에 맞게 현실에서 필요한것만 뽑아내는 것이 중요하다. 이를 **추상화**라고 한다. abstract.

`해결해야할 문제를 소프트웨어적으로 단순화시켜서 만든 행위.`

설계를 한다는 것은 복잡한 현실을 추상화하는 과정이라고 보면 된다.

# 75강

## 객체지향프로그래밍: 부품화

만약 댓글 기능과 관련된 객체를 만들었다고 상상해보자. 우리는 다른 웹페이지를 만들때도 사용할 수 있을 것이다. 이런 상황에서 객체는 하나의 부품처럼 사용된다고 볼 수 있다.

좋은 로직(객체)은 재활용 가능하도록 만들어진 것이다.

__하드웨어 기기로 예를 들어보자__

현재 우리가 사용하는 컴퓨터는 모니터, 본체, 키보드, 마우스처럼 기능별로 나뉘어져있다. 이렇게 기능별로 각각 나뉘어있어 고장이나도 교체가 편리하다. 만약 옛날 컴퓨터처럼 모든 기능이 하나의 제품으로 소속되어 있었다면 다른컴퓨터에 부품을 사용할 수 없는 것은 물론이거니와 고장이 났을 때 수리도 곤란했을 것이다.

그러나 부품화를 어떻게 하느냐에따라 그 모양은 달라지기도 한다. 부품화는 어떻게 해야한다 라는 규칙이 있는 것은 아니며, 가장 중요한 것은 자신이 처한 환경에서 적합함을 찾아 부품화를 하는 것이 제일 중요하다.

자신의 필요함에 따라 부품을 나누어 sw를 구성하는 것이 바람직하다는 것이다. 

> 메소드는 부품화의 대표적인 예라고 할 수 있다. 


#### 은닉화, 캡슐화

제대로된 부품화는 어떻게 동작하는지 모른다하더라도 사용하는 방법만 알면 쓸 수 있도록해야한다. 즉, 내부의 동작 방법을 케이스 안으로 숨기고 사용자에게는 부품의 사용방법만을 노출해도 사용할 수 있어야하는 것이다.

객체가 무엇인지 몰라도 사용할 수 있도록 하겠다는 것이 목표이다.  

> 객체안에 어떤 변수와 메소드가 있고, 어떤 인자를 받는지..

#### 인터페이스

장치와 장치를 연결하는 연결점이 인터페이스라고한다. 이러한 인터페이스가 있기 때문에 가치가 높아지는 것이고, 사용할 수 없는 관계에 있는 것들끼리는 연결되지 못하도록 강제할 수 있다.

# 76강

## 생성자와 new: 소개

js계열에 속하는 언어: prototype-based programming

js에서의 객체 개념: 객체지향 언어의 성격을 가지면서 함수형 언어의 특성도 가지고 있는 언어.

매우 자유롭고 유연하다. 다른 언어보다 규제가 덜 엄격한 느낌이다. 

__객체 복습__

관련된 변수와 메소드를 하나의 그릇에 담는 것. 연관된 것을 그룹핑한다.

> 좋은 부품의 로직을 만들자.

# 77강

## 생성자와 new: 객체 생성

> 객체 내 변수: property / 함수: method

`var person = {}` 에서 {}는 빈 상자를 의미하며 Object이다. 

```
person.name = 'hyun';
person.introduce = function(){
	return 'My name is' + this.name;
}
// 프로퍼티안에 메소드가 담겨있다.
```
해당 코드에서의 this는 **해당 함수가 속해있는 객체**를 가리키는 것이다.

객체를 정의하는 부분을 합쳐보자

```
var person = {
	'name' : 'egoing',
	'introduce' : functino (){
		return 'My name is' + this.name;}
};
```

위와 같은 객체가 있을 때, 여러 사람을 만들고싶다고 생각해보자! 만들고자 하는 만큼 코드를 복붙하면 되겠지만, 중복성과 유지보수에 대한 문제가 발생한다.

이런 상황에 생성자 new를 쓰면 된다!

# 78강

## 생성자와 new

#### new

객체를 만드는 역할을 하는 함수. 함수는 객체라고 볼 수있다.

`var p = new person();`

new 라는 연산자가 붙으면 함수가 객체(생성자)가 된다. new로 인해서 하나의 객체가 만들어지는 것이다.

함수가 객체의 메소드로 쓰일 수 있지만, 객체의 생성자로 쓰일 수도 있다.

__77강 코드 수정__

```
function Person(name){
	this.name = name;
	this.introduce = function(){
		return 'My name is' + this.name;
	}
}

var p1 = new Person('hyun');
document.write(p1.introduce() + "<br />")
```

위와같이 함수를 정의해놓을 때, 몇명의 사람을 만들던 introduce 프로퍼티의 중복되는 부분이 사라지는 것을 확인할 수 있다. 여기서의 person은 함수가아니라 생성자이다.

위와 같이 생성자가 하는일은 초기화의 기능도 있다. 엄밀히 말하면 객체의 초기화이다. 빈 객체를 생성했을 때 어떠한 프로퍼티와 메소드를 가지는지, 그 객체가 가지는 정보, 그 객체가 하는 일을 **초기화(init)**이라고 한다.

# 79강

## 전역객체

특수한 객체를 의미한다. 모든 객체는 이 전역객체의 프로퍼티이다.

```
function func(){
	alert("hi");
}

func();

// 다른 방법으로 호출. 결과는 같다.
window.func(); // func는 window라는 객체의 메소드가 된다.
```

위와 같은 코드에서 window가 전역객체이며, 생략을해도 자연스럽게 붙어있다(눈에 보이지는 않지만). 이를 암시적이라고 한다.

그렇기에 어떤 변수(전역변수라도)던 메소드이던 전역객체의 프로퍼티에 속하는 것이다.

> 전역객체의 이름은 호스트 환경에 따라서 달라질 수 있다. (nodejs 에서는 global) 

# 80강

## this: 함수와 this

this는 함수 호출 맥락을 의미한다. 즉, 고정되어 있는 것이 아니라, 사용하는 상황에 따라 그 의미가 달라질 수 있다는 걸 의미한다.

this는 함수 안에서 사용되는 키워드로, js안에서 약속된 변수이다. this는 함수에서 어떻게 쓰이느냐에 따라 값이 달라질수 있는 변수이다.

# 81강

## this: 메소드와 this

```
var o = {
	func: function(){
		if(o === this){
			document.write("o === this");
		}
	}
}

o.func();
```

를 실행하면 "o === this"가 제대로 출력된다.

즉, 메소드가 소속된 객체를 this로 접근할 수 있는 것이다.

__정리__

함수를 호출하는 것과 객체에서 메소드를 호출하는 것은 다른 것처럼 보일 수 있으나 사실은 비슷한 맥락이다. 

함수를 호출하는 것처럼 보여도 `window.func();` 와 같이 전역객체에 속해 동작하므로, 객체에 속한 메소드를 호출하는 것과 크게 다름이 없기 때문이다.

# 82강

## this: 생성자와 this

```
var funcThis = null;

function func(){
	funcThis = this;
}

var o1 = func();
if (funcThis === window){
	documents.write('window');
}

// 함수 호출시 전역객체 window가 this에 담긴다.

var o2 = new func();
if (funcThis === o2){
	documents.write('o2');
}

// 객체가 생성자 안에서의 this가 된다.
```

생성자로 사용될 때는 this의 값이 생성된 객체가된다. 

__순서__

1. 생성자를 호출하여 객체를 생성한다.
2. 생성자의 내용을 쭉 실행한다.
3. 변수에 할당한다.

즉, 순서에 따라 아래와 같은 코드가 불가능하다.

```
function func(){
	if(o2 == this){...}
}
```

o2가 아직 변수에 담기지 않아 undefined 되어있기 때문이다.

생성자를 호출하면, 생성자가 쭉 실행되는 과정에서 객체의 이름은 정의되어 있지 않다고 볼수 있다. 생성된 객체가 아직 변수에 담기지 않았기 때문이다.

this라는 것은 생성(초기화)이 끝나서 어떤 식별자에 담기기전에 우리가 그 객체를 참고할 수 있는 식별자이므로 필수적으로 있어야한다.

> 복습: this는 생성자가 만든 객체를 가리킨다.

# 83강 

## this: 객체로서의 함수

함수는 apply와 call이라는 메소드를 가지고 있다. 

```
function sum(x,y){return x+y;}

// 와 아래의 코드는 비슷하다고 할 수 있다.

var sum2 = new function('x','y','return x+y;');
// 마지막에 등장하는 인자가 리턴값이 된다.
sum2 (1,2);

```

#### 리터럴

편리하게 어떠한 값을 만들도록 해주는 문법적인 체계

__리터럴 사용의 예__

`function sum(x,y){return x+y;}` 는 함수리터럴이라 한다.

`var o = {};` 는 객체리터럴,

`var a = [];` 는 배열리터럴이다. 

`new (object, array, function())` 의 형식으로 생성할수도 있지만 불편하니까 리터럴을 쓰는 것이다. 

# 84강

## this: apply와 call

> 객체라면 프로퍼티를 가질 수 있다.

```
var o = {}
var p = {}
function func(){
	switch(this){
		case o:
			document.write('o');
			break;
		case p:
			document.write('p');
			break;
		case window:
			document.write('window');
			break;
	}
}

func(); // window
func.apply(o); // 
func.apply(p);
```

> apply의 첫번째 인자는 함수 호출의 컨텍스트를 대입하는 것이다. 

다른언어에서의 객체는 일반적으로 메소드는 강하게 객체에 소속된다. 메소드는 다른 곳에 가지못하고 객체에 고정된다. 

그러나 js에서는 함수자체도 일종의 객체가될 수 있으며, 어떻게 호출하느냐에 따라 다른 객체에 소속될 수도있다. 객체에 소속이 되기도 하고, 객체가 되기도하는 것이다.

__이런 이유로, 자바스크립트는 유연하다고 할 수 있다.__

# 85강

## 상속: 상속이란?

객체는 하나의 컨테이너고 그 안에는 작업과 관련된 변수와 메소드가 모아져있다. 그런 객체의 특성으로 인해 객체의 특성을 물려받아 새로운 객체를 만들 수 있다. 

이럴 때 원본 객체는 부모이고, 객체의 특성을 그대로 물려받아 만든 새로운 객체는 자식이라고 한다.

이를 상속이라하며, 상속을 통해 필요한 메소드나 변수는 추가하고 필요없는 것은 버리며 로직을 재활용할 수 있다는 장점이있다.

__객체 prototype__

하나의 약속된 프로퍼티인 prototype을 보자

```
function Person(name){
	this.name = name;
}

Person.prototype.name = null;
Person.prototype.introduce = function (){
	return 'My name is' + this.name;
}
```

person이라는 생성자에는 프로토파입이라는 프로퍼티가있고, 그 안에는 객체가들어가있다. 

# 86강

## 상속: 상속의 사용방법

상속의 작동 방법을 알아보자

```
function Person(name){
	this.name = name;
}
Person.prototype.name = null;
Person.prototype.introduce = function() {
	return 'My name is' + this.name;
}

// 프로그래머도 사람이므로, 사람의 생성자를 상속하도록하겠다.
function Programmer(name){
	this.naem = name;
}
Programmer.prototype = new Person();

var p1 = new Programmer('egoing');
documents.write(p1.introduce());
```

프로그래머라고하는 생성자가 가지는 특수한 프로퍼티인 프로토타입의 값으로 person 생성자를 넣은 것이다. 

person생성자에 의해 객체가 생성되는데, 생성할 때 프로토타입이라는 속성을 (부모)생성자가 가지고 있는지 확인한다. 그리고 그 생성자 함수의 프로토타입 속성 안에있는 변수와 메소드를 똑같이 만들어서 객체를 전달해준다.

이렇게 부모로부터 객체가 생성되어 상속받는 객체의 프로퍼티 속성안으로 들어가는 것임.

> 어떠한 객체를 상속받고 싶다면 그 객체를 생성자의 프로토타입에 할당시키면 된다.

# 87강

## 상속: 기능의 추가

그렇다면 어떻게 상속받은 객체의 기능을 추가할 수 있을까?

```
function Person(name){
	this.name = name;
}
Person.prototype.name = null;
Person.prototype.introduce = function() {
	return 'My name is' + this.name;
}

// 프로그래머도 사람이므로, 사람의 생성자를 상속하도록하겠다.
function Programmer(name){
	this.name = name;
}
Programmer.prototype = new Person();
// programmer 생성자만 가지는 coding이라는 기능 추가
// 프로그래머 생성자만 가져야하므로 아래와 같이 작성해야 한다.
Programmer.prototype.coding = function(){
	return "hello world";
}

var p1 = new Programmer('egoing');
documents.write(p1.introduce());
documents.write(p1.coding());

```

디자이너 생성자를 추가해보자.

```
function Designer(name){
	return 'My name is' + this.name;
}

// person 상속받고 기능추가.
Designer.prototype = new Person();
Designer.prototype.design = fuunction(){
	return "hello design";
}

```

Programmer와 Designer는 Person의 생성자를 상속받아 각각에 맞는 기능을 추가했다.

> prototype 은 자바스크립트에서 매우 중요하며 그렇기 때문에 prototype-based 언어라고도 하는 것이다.

# 88강

## 프로토타입: 프로토타입이란?

> prototype: 원형; 자바스크립트를 다른 객체지향 언어와 구분짓는 중요한개념

__상속을 계층적으로 받는다면?__

부모에 정의된게 없다면 부모의 부모로 가서 해당한는 것이 있는지 찾는다.

__생성자의 역할__

생성자는 기본적으로 함수이다. 함수 앞에 new를 붙여주면 생성자가 되며, 새로운 객체를 만들어서 객체를 리턴하여 변수에 할당하게 된다.

> 객체가 기본적으로 갖춰야하는 변수나 메소드를 제공하므로 빈 객체를 생성하는 것보다 유용하다.

#### 프로토타입

우리가 얻고자하는 객체의 원형(어떤 메소드와 어떤 프로퍼티를 가지고 있는지)을 어딘가에 저장해야하는데, 이를 프로토타입이라는 프로퍼티에 저장하는 것이다.

프로토타입이라는 특수한 프로퍼티안에는 객체가 정의되어있다. 생성자를 호출하면 생성자 함수의 프로토타입에 저장된 객체를 꺼내서 리턴을 해주게 된다.

# 89강

## 프로토타입: prototype chain

> 서로가 서로를 연결하는 관계

__주의할 점__

```
function Ultra(){}
Ultra.prototype.ultraProp = true;

function Super (){}
Super.prototype = new Ultra;

function Sub(){}
Sub.protptype = new Super();

```

위와 같은 코드가 있을 때 `Sub.prototype = Super,prototype;`을 사용하지는 말자. 이렇게 하면 멀쩡히 돌아가는 것처럼 보인다.

그러나 위와같이 정의한 후 서브의 프로토타입에 있는 어떠한 객체에 다른 값들을 주게되면 super의 프로퍼티에 영향을 주기때문에, 하위 객체의 변경이 부모 객체의 변경이 되는것과 동일해지는 것이다.

> 자식에게 일어나는 일이 부모에게도 일어날 수도 있기 때문에, 부모의 프로토타입을 사용하지 말고, 만들어진 복제본을 사용하도록하자.

# 90강

## 표준 내장 객체란?

자바스크립트가 기본적으로 가지고있는 객체들을 의미한다.

> Standard built in object

1. Array
2. Object
3. Function
4. String
5. Boolean
6. Number
7. Math
8. Date
9. RegExp

JS를 이용하는 호스트환경에따라 다른 객체들이 추가될 수 있다.

사용자가 직접 정의해서 사용하는 객체는 **사용자 정의 객체**라고 한다.

이런 사용자 정의 객체와 표준 내장 객체를 연결해서 사용할 수도 있다

> 표준 내장 객체에 필요한 것을 추가하여 사용하는 것을 의미한다.

# 91강 

## 표준 내장 객체의 확장: 배열의 확장 (1)

```
var arr = new Array('seoul','pusan');

// 값들중 하나를 랜덤하게 가져오는 코드를 짜보자

function getRandomValue(arr){
	var index = Math.floor(Math.random() * arr.length);
	return arr[index];
}
```

> math.floor : 소수점 아래의 수를 버리는 메소드.

# 92강

## 표준 내장 객체의 확장: 배열의 확장 (2)

91강에 작성한 코드를 수정해서 작성해보자. 배열에서 랜덤하게 하나를 얻는 함수를 만들었다.

```
// 함수가 객체안에 들어있을때의 이름의 복잡도는 다르다!
// 배열객체의 원형에 랜덤이라는 메소드를 추가한다.
Array.prototype.random = fucntion(){
	// 만들어진 배열객체 자체를 가리킨다.
	var index = Math.floor(Math.random() * this.length);
	return this[index];
}
```

실행은

`arr.random()`을 하면 된다. 위와 같은 코드는 인자가 없으니 사용자가 신경쓸 것을 덜어준다. 

> 프로토타입 확장을 통해 모든 배열이 가져야하는 API를 바꿀 수 있다는 것은 매우 매력적이다.

# 93강

## object: 오브젝트란?

object라는 이름을 가진 object가 존재한다. 편하게 말하기 위해 오브젝트 객체라고하자. 오브젝트라는 객체의 속성은 모든 객체가 가진 속성이 된다. 오브젝트라는 객체는 모든 객체의 부모다. 

즉, `object.prototype` 은 모든 객체들의 원형이 되는 것이다. 

1. 오브젝트 객체의 프로토타입은 모든 객체가 사용할 수 있는 기능이다.
2. 모든 객체가 가지고 있었으면 하는 기능이 있다면, 오브젝트의 프로토타입으로 기능을 추가하면 된다.

# 94강

## object: 오브젝트 API 사용법

[이곳을 보며 확인하자](https://developer.mozilla.org/ko/docs/Web/JavaScript)

__두가지 메소드의 차이를 보며 .prototype이 있고없고의 차이가 무엇인지 보도록하자__

`Object.keys(객체)`와 `Object.prototype.toString()` 을 사용한다.

```
// keys()
var arr = ["a","b""c"]
console.log('Object.keys(arr), Object.keys(arr));
// 0,1,2

// prototype.toString()
var o = new Object();
console.log('o.toString()', o.toString());
var a = new Array(1,2,3);
console.log('a.toString()', a.toString());
```

> prototype.toString() : 객체가 담고있는 값이 무엇인지 사람이 보기좋게 출력해주는 기능. 문자열로 출력한다.

> keys() : 키값들을 배열로 리턴하는 메소드.

__프로토타입이 있는 것__

프로토타입이 있는 것은 어떠한 객체를 만든다. 그리고 객체를 넣은 식별자에 `.`을 붙여 사용한다. `o.toString();`

메소드가 프로토타입에 속한다는 것은 new object();를 실행시키는 순간에 객체를 만들고, 우리가 호출한 생성자에 프로토타입이라는 특수한 속성에 저장된 객체를 원형으로하는 원형의 객체가 생성된다. 객체를 생성하고, 객체에 대한 메소드로서 사용하게 되는 것임.

__프로토타입이 없는 것__

`Object.keys(객체);` 처럼 인자로 어떠한 값을 받아서 생성한다. 

__정리__

오브젝트의 프로토타입이 껴있는 메소드들은 모든 객체에서 사용이 가능하다. 오브젝트 객체는 모든 객체의 조상이기 때문이다. 그렇기 때문에 모든객체가 공통적으로 가지고 있어야하는 기능이 필요하다면 오브젝트의 프로토타입을 수정하면된다.

# 95강

## object: 오브젝트 확장

어느 객체에서나 사용할 수 있는 메소드를 만들어보자 

구현할 메소드는 이것이다.

```javascript
var o = {'name':'hyun','city':'seoul'}
console.log(o.contain('hyun'));
var a = ['hyun', 'sue', 'sun'];
console/log(a.contain('sue'));
```

인자를 전달하면 인자에 해당하는 값이 객체안에 있는지 없는지를 체크하고  boolean 타입을 리턴한다.

> 자신이 만들 것이 어떻게 사용될지를 설계하고 구현하는 것이 중요하다. 

구현해보자

```
Object.prototype.contain = function(needle){
    for(var name in this){
        if(this[name]===needle){
            return true;
        }
    }
    return false; // 존재하지 않는 값.
}
```

프로타입이라는 생성자의 프로퍼티 안에 들어있는 객체를 변경한다.

# 96강

## object: 오브젝트 확장의 위험

오브젝트의 확장은 위험하며 가급적 하지않는 것이 좋다. 모든 객체에 영향을 주기때문에 신중하게 확장해야한다. 

만약 메소드를 추가하여 오브젝트를 확장했다면,  객체를 만들때마다 객체 안에 해당 메소드가 포함되기 때문이다. 

객체나 배열을 정의하는 사람은 자신의 정의한 데이터가 열거될 것이라 기대하는데, 오브젝트에 새로 추가된 프로퍼티나 메소드가 같이 열거되는 것이다.

__해결법__

`o.hasOwnProperty` 프로퍼티를 사용하면 이를 방지할 수 있다.  오브젝트가 가진 메소드이며, 모든 객체가 해당 메소드를 가지고 있다.

```
for (name in o){
    if(o.hasOwnProperty(name)){
        console.log(name);
    }
}
```

> 객체가 인자로 전달받은 값을 자신의  프로퍼티로 가지고 있는 지를 체크한다. contain은 부모로 부터 상속받았기  때문에  걸러진다.

객체의 직접적인 소유인지, 직접적으로 정의된 녀석인지를 체크하는 기능이다. 상속받은 프로퍼티와 소유하고 있는 프로퍼티를 구분할 수 있는 것이다.

# 97강

## 원시 데이터 타입과 객체

여러 데이터 타입을 어떤 기준에 따라 분류를해서, 같은 카테고리안의 유사한 부분, 그리고 다른 카테고리간의 차이점을 살펴보도록하자.

__데이터타입의 구분__

1. 원시 데이터 타입 (기본데이터 타입)
   - 숫자, 문자열, 불리언, Null, undefined
   - 객체가 아닌 데이터 타입을 원시 데이터 타입이라고 한다.
2. 객체 데이터 타입 (참조 데이터 타입)

# 98강

## 래퍼 객체

원시 데이터 타입과 객체가 서로 다르게 동작해야 효용이 있을테니, 이 과정을 살펴보도록하자.

```javas	cript
var str = 'coding';
console.log(str.length);
console.log(str.charAt(0));
```

위의 코드를 보면 문자열이 객체로 쓰인다. 분명 원시데이터라고 했는데 어떻게 된 일일까!

> `.` : Object access Operator ; 점 앞에있는 것은 객체라는 것을 알 수 있다.

문자열이 원시데이터가 맞기는 하지만, 문자열을 제어하기 위해서는 문자열이 마치 객체인 것처럼 동작해야한다. 그런 이유로 인해서 자바스크립트에서는 원시데이터를 임시로 객체로 만들어준다.

`str = new String('coding');` 과 같이 객체를 생성해 담아주는 코드가 숨겨져 있다고 보면 이해하기 쉬울 것이다. 

그렇다면 `str.prop='hi';` 와 같이 코드를 입력했다고 해보자. 결과적으로 에러가 나지는 않는다. str을 객체처럼 여기기때문에 그런 것이다. 하지만 콘솔에 str.prop를 찍어보면 undefined가 뜬다. 

prop를 할당하고 문장이 끝난 순간,  객체를 제거하고 원래의 원시데이터 타입으로 돌려놨기 때문이다. 즉, 원시데이터 타입을 마치 객체처럼 사용하려고 할 때 내부적으로 자동으로 만들어 지는 객체를 **래퍼 객체**라고 한다. 

> 원시데이터 타입을 감싸주는 객체라고해서 래퍼이다.

원시데이터는 객체처럼 사용할 수가 없는데, 래퍼 객체를 통해 객체처럼 사용할 수 있는 것이다. JS는 내부적으로 이를 알아서 해준다.

1. 숫자: Number
2. 문자열: String
3. 불리언: Boolean

# 99강

## 참조: 복제란?

전자화된 시스템에서 데이터의 복제는 아주 쉽고 빠르다. 프로그래밍에서는 복제가 어떻게 사용될까?

```javascript
var a = 1;
var b = a;
b = 2;
console.log(a); // 1
```

참조라는 개념을 잠시 미뤄두자. a에 담긴 1이 복제되어 b에 담기는 것이다. 복제된 데이터는 변경해도 원래의 데이터에 영향을 주지 않는다.

> 참조의 개념에서 보면, a가 참조하던 값이 똑같이 하나 더 만들어져 b가 참조하는 것이다.

# 100강

## 참조

변수에 담긴 값이 원시데이터 타입일 때 복제가 일어난다. 그렇다면 변수에 담긴 값이 객체일 때는 어떻게 달라질까?

```javascript
var a = {'id':1};
var b = a;
b.id = 2;
console.log(a.id); // 2

```

b의 프로퍼티를 변경했는데, a의 프로퍼티까지 변경된 것이다. 이는 객체에 대한 참조가 이루어지기때문에 가능한것이다.

원시데이터와 다르게 객체는 복제가 되는 것이아니라, 같은 객체를 참조하게 되는 것이다. 객체에 접근할 수 있는 주소 2개를 가지고 있는 것이라고 생각하면 된다. 마치 바로가기 폴더라고 보면 이해하기 쉬울 것이다.

> `b=a`를 했을 때, 객체는 변수들이 똑같은 객체를 바라보는 것이고, 원시데이터는 같은 값을 바라보게하는데 별개의 복제된 값을 바라보게 한다.

# 101강 

## 함수와 참조

```javascript
var a = 1;
function func(b){
    b = 2;
}
func(a);
console.log(a); //1

```

이 과정은, `a=1`, `b=a`, `b=2`의 형태가 된다. 즉, b에 a의 값을 복제해서 참조하게 한것이다.  복제는 서로에게 영향을 미치지 않으므로, 함수안에서 b를 바꿔도 a에 담긴 것에는 영향을 주지 않는다.

하지만 객체를 인자로 넘긴다면 어떻게 될까? 

```javascript
var a = {'id':1};
functino func(b){
    b.id = 2;
}
func(a);
console.log(a.id); // 2

```

b가 a와 같은 것을 **참조**하고 있는 것이기 때문에, a에 영향을 미친다.

> 숫자와 문자, 불리언은 원시데이터지만 래퍼객체를 통해 객체처럼 사용할 수 있다. 헷갈리지 않도록 하자.
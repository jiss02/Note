# 31강

## 함수: 입력

```
function get_arg1000(arg){
	return arg*1000;
}
```

arg는 파라미터이며, 변수이다. 

예를들어, `get_arg1000(2);`이며 2는 arg에 담긴다.

위의 예제를 기반으로 개념을 나누자면, 

- arg : parameter; 매개변수
- 괄호안에 들어가는 값: argment; 인자

### 복수의 인자

인자는 여러개가 들어가는 것이 가능하다

```
fuction get_arg(arg1, arg2){
	return arg1 + arg2;
}
```

# 32강

## 함수의 다양한 정의 방법

`변수 = function () {return}` 의 형태로 함수를 정의할 수 있다. 변수가 함수를 담고있게 되는 것임.

__익명함수__


```
(function () {return})();
```
함수를 정의하자마자 바로 쓰는 것이다. 이름이 없어 익명함수이며 일회성호출하는 경우 사용한다. 

js는 함수형 언어라고 할 정도로 함수가 차지하는 위상이 매우 높다고 할 수 있으니 잘 알아두자.

# 33강

## 배열

연관된 데이터를 모아서 통으로 관리하는 데이터 타입이다. 변수가 하나의 데이터를 저장하기 위한 것이라면 배열은 **여러개의** 데이터를 하나의 변수에 저장하기 위한 것이라고 볼 수 있다. 

```
var member = ['영희','철수','민희']; 
```

alert(member); 을 사용하면 콤마로 원소를 구분하여 알림창을 띄워준다. 

배열안의 데이터 하나하나는 원소라고 하며 영어로는 element이다. 

배열의 인덱스(고유한 식별자)는 0부터 시작한다. 

`member[index]`의 형태를 사용하여 인덱스에 해당하는 원소를 꺼낼 수 있다. 

# 34강

## 배열의 효용

__배열이 없다면?__

함수는 여러개의 입력을 받을 수 있지만 하나의 값만 리턴(출력)이 가능하다. 이런 함수의 한계를 극복할 수 있는 것이 배열이다. 배열이 없다면? 하나씩 리턴값을 주어야하므로 원소 수 만큼 함수를 만들어야할 것이다.

# 35강

## 배열과 반복문의 조우

반복문과 배열은 아주 긴밀한 관계를 가진다. 

```
function mem(){
	return ['a','b','c']
}

member = mem();

for(var i = 0; i < member.length; i++){
	document.write(member[i].length.toUpperCaxe()+"<br />");
} 

```

반복문이 없다면 한줄한줄 코드를 작성해야 했을 것이다! 원소의 수에 따라 탄력적으로 변경이 가능해진 것이다. 

> str.toUpperCase(); 는 대문자로 바꿔주는 함수다. 

> 배열.length; 는 원소의 개수를 반환한다.
> 

# 36강

## 배열의 제어: 데이터 추가

`array.push('something');` 명령어를 통해 배열 뒤에 새로운 원소를 추가할 수 있다. 

만약 여러개를 넣고 추가하고 싶다면, `arr.concat(['s','t']);` 명령어를 사용하면 된다. concat의 인자는 배열이어야한다.

뒤가 아닌 배열의 앞에 원소를 넣고 싶다면,
`arr.unshift('a');` 명령어를 사용하면 된다.

배열의 어딘가에 낑겨넣고 싶다면,
`arr.splice(indew, howmany, el1, ..., elN); ` 명령어를 사용하면 된다.

- splice(어디에 넣을지에 대한 인덱스,index에서 제거될 원소의 수, index+howmany 사이에 추가될 원소)
- howmany에 특정 값을 넣으면 인덱스부터 howmany 개수만큼에 해당하는 원소들은 삭제된다. 0이면 어느 원소도 삭제되지 않는다.

> splice는 삭제되는 원소를 배열의 형태로 리턴해주는 기능도 있다. 

# 37강

## 배열의 제어: 제거와 정렬

__첫번째 원소 삭제하고 싶을때__

arr.shift();

__뒤의 데이터 제거__

arr.pop();

### 정렬 

정렬은 매우 중요하다! 얼마나 빠르게 정렬하느냐에대한 논의가 많이 이루어지는데 이는 나중에 보도록 하자.

arr.sort();

를 사용하면 정렬을 해준다. 만약 역순으로 하고싶다면,

arr.reverse();

를 사용하면 된다. 

해당과 같은 정렬 함수는 JS에서 자체적으로 가지고 있는 정렬방식을 사용한 것이다. 

# 38강 

## 객체: 객체의 문법

영어로는 **Object** 이다. 배열과 유사한 역할을 하지만 다르다. 연관된 데이터를 담아내기위한 그릇이라는 점에서 유사하지만, 객체의 경우 인덱스의 값으로 숫자나 문자 등 사용자가 원하는 데이터로 인덱스를 설정할 수 있다. 가시적인 차이는 일단 여기까지 설명하겠다!

### 객체에 해당하는 것들

1. 맵
2. 연관배열
3. 딕셔너리

객체지향이라는 패러다임과 중요하게 연결되는데, 일단 데이터를 담는 컨테이너로 간단하게 생각하자. 객체 지향에 대한 설명은 뒤에서 설명한다.

### 객체의 생성

객체는 중괄호로 시작해서 중괄호로(`{}`) 끝난다.

```
var score = {'math':90, 'eng':75};
```

> 변수에 담아서 언제든 제어할 수 있도록하자.

여기서 math나 eng는 **key** 이고 90이나 75는 **value** 이다.

__객체에 원소 추가__

```
var grades={};

grades['math']=75;
grades['eng']=90;

```

또는 new Object() 를 사용하여 생성할 수도 있다.

```
var grades= new Object();

grades['math']=75;
grades['eng']=90;

```

__객체 접근__

`obj[key값]`의 형태로 입력하면 해당 키에 해당하는 value를 얻을 수 있다.

- grades['math'];
- grades.math;
- grades['ma'+'th'];

전부 같은 의미다.

# 39강 

## 객체: 객체와 반복문의 조우

배열은 저장된 데이터들이 순서를 가지고 있다. 먼저 들어간 것과 나중에 들어간 것이 기록되는 것이다. 집어넣은 순서대로 끌어올 수 있는 것이다.

그러나 객체는 순서가 없다. 키가있고 밸류가있을 뿐이다. 저장된 순서가 없기 때문에 순서가 없다고 생각하고 객체를 다루도록 하자.

```
var score = {'math': 60, 'eng':40 ,'history': 90};

for(key in score){
	document.write("key : " + key + "value: " + score[key] + "<br />");
}
```

__for a in Object__

객체 안에 있는 것을 하나씩 가져와 a에 담는다. 객체의 키와 밸류 전체를 담는 것이 아니라 객체의 키를 담는 것이다. 객체의 원소를 하나씩 가져오며 반복한다.

배열에서도 for in 을 사용할 수 있다.

```
for (index in arr){
	console.log(arr[index]);
}
```

> console.log(); 콘솔창에 보여줍니다.

__팁: HTML 리스트를 JS를 통해 만들어보자__

```
for(key in score){
	document.write("<li>key : " + key + "value: " + score[key] + "</li>");
}
```
이렇게 앞과 뒤에 li 태그를 넣어주면 된다.

# 40강

## 객체: 객체지향 프로그래밍

객체에 담길 수 있는 값는 무엇일까.

```
var grades = {
	'sam' : {'math':90, 'eng':75}
	'show' : function(){alert('hello');}
}
```

만약 샘의 수학점수가 보고싶다면 `grades['sam']['math']` 와 같이 접근하면 된다.

js에서는 함수도 일종의 값이며 저장이 될 수 있다.

__this__

this는 약속된 변수로, 함수가 속한 객체를 가르키는 변수이다.

```
var grades = {
	'sam' : {'math':90, 'eng':75}
	'show' : function(){
		for (name in this.sam){
			console.log(name, this.sam[name]);
		}
	}
}
```
여기서의 this는 함수가 소속된 객체 grades를 가리킨다. this.sam 이면, grades의 'sam'을 의미하는 것이다.

> 객체에 소속된 함수를 호출할때는 grades.show(); 의형태로 호출한다!

즉, 객체를 통해 연관있는 것 끼리 묶을 수 있는 것이다! 연관된 값과 함수 등.. 이런 것이 객체지향 프로그래밍이다. this와 객체의 심화적인 부분은 더 뒤에서 다루도록하자.
















# 71강

## 함수의 호출: apply 소개

js에서 함수는 하나의 객체이다. 그리고 객체는 속성을 가진다. 이때 속성에 값이 저장되어있다면 **속성**, 그런데 함수가 들어있다면 **메소드**라고 부른다.

함수는 객체이며, 함수에는 js에서 제공하는 메소드를 사용할 수 있다.

```
func.apply
func.call
```
을 통해 함수를 호출할 수 있다.

#### apply

apply는 함수다. `func.apply`코드를 통해 함수라는 객체에 담긴 메소드라는 것을 확인할 수 있다.

내장된 코드면 native code를 띄우며 내부 코드를 보여주지 않는다.

두 값을 더하는 sum함수가 있다고 치고 예제를 보자

```
sum.apply(null, [1,2]);
```

배열안의 0번째 값이 첫번째 인자로, 1번째 값이 두번째 인자로 들어간다.

__왜 이렇게 호출하는가?__

apply의 첫번째 인자에 다른 것을 넣을 때 사용하라고 존재하는 것이다! 첫번째 값이 null값이면 딱히 사용할 이유가 없다.

# 72강

## apply의 사용

```
o1 = {var1: 1, val2: 2, val3: 3}
o2 = {v1:10, v2:50, v3:100, v4:25}

fuction sum(){
	var _sum = 0;
	for (name in this){
		_sum += this[name];
	}
	return _sum;
}

alert(sum.apply(o1))
alert(sum.apply(o2))
```

#### apply가 없다면

sum이 호출되면서 객체를 인자에 주게되고, 인자로 준 객체가 this가 된다. 암묵적으로 `var this = o1;` 이런 코드가 들어간다고 생각하면 쉽다.

```
alert(sum.apply(o1))
```

이렇게 되는 순간에, o1.sum() 이 되는 것이다. o1객체의 sum메소드가 들어간것이 되는 것이다.

```
o1 = {var1: 1, val2: 2, val3: 3, sum:sum};
alert(o1.sum());
```

하지만 이런 식을 사용하면 결과에 함수 내용도 나오게 되는 문제가 발생한다. 함수가 객체 안에 들어가면서 for문이 돌때 함께 돌기 때문이다. 이를 방지하기 위해서는 for문을 아래와 같이 고치면 된다.

```
for (name in this){
	if (typeof this[name] !== 'function'){
		_sum += this[name];
		}
	}
```

객체에 함수를 따로 추가하고 어쩌고... 이런 번거로운 과정들을 apply라는 것을 사용하여 간단하게 표현할 수 있는 것이다. 

# 73강

## 객체지향프로그래밍: OT

OOP: Object Oriented Programming

#### 객체가 도대체 무엇일까?

추상적으로, 상태와 행위로 이루어진 것이 객체이다. 객체들을 마치 이렇게 저렇게 조립해서 하나의 프로그램을 만드는 것이 OOP라고 할 수 있다.

하나의 프로그램은 여러개의 목적성을 가진 로직들의 집합이라고 볼수 있다. 작은 프로그램이라면 괜찮지만, 프로그램이 커지고 관리하는 사람이 많아질수록 코드가 복잡해지니 비슷한 로직들을 기능적으로 구분하고 정리하고 싶다는 욕구가 드는 것은 당연할 것이다. 

이런 욕구로 인해 서로 연관된 것들끼리 그룹핑을 할 방법을 모색하다가 등장한 개념 중 하나가 객체라고 생각하면 더 이해하기 쉬울 것이다.

__자세히 알아보자__

변수와 메소드를 서로 연관되어있는 것 끼리 그룹핑하는 것을 프로그래밍 언어 차원에서 제공하는 것이다. 이렇게 그룹핑된 하나하나의 단위들을 객체라고 한다.

만약 글목록이라는 기능과 연관된 변수와 메소드가 있다면, 이들끼리 객체라는 단위로 응집되어 있는 것이다. 다른 성격을 가진(연관성이 없는) 로직들과는 객체라는 껍데기로 분리되어있는 것이다.

분류하고 카테고라이징하다보니 객체라는 기능이 나타나게 된 것이다.

__요약__

객체지향프로그래밍은 객체를 만드는 것이고 객체는 구체적이고 문법적인 기능이 언어적으로 제공된다. 하나의 객체 안에는 그 객체가 가진 취지에 따라 그 취지에 연관된 변수와 메소드가 들어있다. 그리고 연관성이 없는 다른 로직과 구분짓는 선이기도 하다.

# 74강

## 객체지향프로그래밍: 추상화

두가지의 접근이 필요하다.

1. 문법적 요소
2. 설계
	- 현실에서 관심있는 어떤 특성을 sw화 시켜서 문제를 풀어나가는 것.
	- 현실은 매우 복잡하기 때문에 문제에 맞춰 필요한 부분만 잘 뽑아오는 것이 중요하다.

즉, 현실에서 우리가 가진 관심사에 맞게 현실에서 필요한것만 뽑아내는 것이 중요하다. 이를 **추상화**라고 한다. abstract.

`해결해야할 문제를 소프트웨어적으로 단순화시켜서 만든 행위.`

설계를 한다는 것은 복잡한 현실을 추상화하는 과정이라고 보면 된다.

# 75강

## 객체지향프로그래밍: 부품화

만약 댓글 기능과 관련된 객체를 만들었다고 상상해보자. 우리는 다른 웹페이지를 만들때도 사용할 수 있을 것이다. 이런 상황에서 객체는 하나의 부품처럼 사용된다고 볼 수 있다.

좋은 로직(객체)은 재활용 가능하도록 만들어진 것이다.

__하드웨어 기기로 예를 들어보자__

현재 우리가 사용하는 컴퓨터는 모니터, 본체, 키보드, 마우스처럼 기능별로 나뉘어져있다. 이렇게 기능별로 각각 나뉘어있어 고장이나도 교체가 편리하다. 만약 옛날 컴퓨터처럼 모든 기능이 하나의 제품으로 소속되어 있었다면 다른컴퓨터에 부품을 사용할 수 없는 것은 물론이거니와 고장이 났을 때 수리도 곤란했을 것이다.

그러나 부품화를 어떻게 하느냐에따라 그 모양은 달라지기도 한다. 부품화는 어떻게 해야한다 라는 규칙이 있는 것은 아니며, 가장 중요한 것은 자신이 처한 환경에서 적합함을 찾아 부품화를 하는 것이 제일 중요하다.

자신의 필요함에 따라 부품을 나누어 sw를 구성하는 것이 바람직하다는 것이다. 

> 메소드는 부품화의 대표적인 예라고 할 수 있다. 


#### 은닉화, 캡슐화

제대로된 부품화는 어떻게 동작하는지 모른다하더라도 사용하는 방법만 알면 쓸 수 있도록해야한다. 즉, 내부의 동작 방법을 케이스 안으로 숨기고 사용자에게는 부품의 사용방법만을 노출해도 사용할 수 있어야하는 것이다.

객체가 무엇인지 몰라도 사용할 수 있도록 하겠다는 것이 목표이다.  

> 객체안에 어떤 변수와 메소드가 있고, 어떤 인자를 받는지..

#### 인터페이스

장치와 장치를 연결하는 연결점이 인터페이스라고한다. 이러한 인터페이스가 있기 때문에 가치가 높아지는 것이고, 사용할 수 없는 관계에 있는 것들끼리는 연결되지 못하도록 강제할 수 있다.

# 76강

## 생성자와 new: 소개

js계열에 속하는 언어: prototype-based programming

js에서의 객체 개념: 객체지향 언어의 성격을 가지면서 함수형 언어의 특성도 가지고 있는 언어.

매우 자유롭고 유연하다. 다른 언어보다 규제가 덜 엄격한 느낌이다. 

__객체 복습__

관련된 변수와 메소드를 하나의 그릇에 담는 것. 연관된 것을 그룹핑한다.

> 좋은 부품의 로직을 만들자.

# 77강

## 생성자와 new: 객체 생성

> 객체 내 변수: property / 함수: method

`var person = {}` 에서 {}는 빈 상자를 의미하며 Object이다. 

```
person.name = 'hyun';
person.introduce = function(){
	return 'My name is' + this.name;
}
// 프로퍼티안에 메소드가 담겨있다.
```
해당 코드에서의 this는 **해당 함수가 속해있는 객체**를 가리키는 것이다.

객체를 정의하는 부분을 합쳐보자

```
var person = {
	'name' : 'egoing',
	'introduce' : functino (){
		return 'My name is' + this.name;}
};
```

위와 같은 객체가 있을 때, 여러 사람을 만들고싶다고 생각해보자! 만들고자 하는 만큼 코드를 복붙하면 되겠지만, 중복성과 유지보수에 대한 문제가 발생한다.

이런 상황에 생성자 new를 쓰면 된다!

# 78강

## 생성자와 new

#### new

객체를 만드는 역할을 하는 함수. 함수는 객체라고 볼 수있다.

`var p = new person();`

new 라는 연산자가 붙으면 함수가 객체(생성자)가 된다. new로 인해서 하나의 객체가 만들어지는 것이다.

함수가 객체의 메소드로 쓰일 수 있지만, 객체의 생성자로 쓰일 수도 있다.

__77강 코드 수정__

```
function Person(name){
	this.name = name;
	this.introduce = function(){
		return 'My name is' + this.name;
	}
}

var p1 = new Person('hyun');
document.write(p1.introduce() + "<br />")
``` 

위와같이 함수를 정의해놓을 때, 몇명의 사람을 만들던 introduce 프로퍼티의 중복되는 부분이 사라지는 것을 확인할 수 있다. 여기서의 person은 함수가아니라 생성자이다.

위와 같이 생성자가 하는일은 초기화의 기능도 있다. 엄밀히 말하면 객체의 초기화이다. 빈 객체를 생성했을 때 어떠한 프로퍼티와 메소드를 가지는지, 그 객체가 가지는 정보, 그 객체가 하는 일을 **초기화(init)**이라고 한다.

# 79강

## 전역객체

특수한 객체를 의미한다. 모든 객체는 이 전역객체의 프로퍼티이다.

```
function func(){
	alert("hi");
}

func();

// 다른 방법으로 호출. 결과는 같다.
window.func(); // func는 window라는 객체의 메소드가 된다.
```

위와 같은 코드에서 window가 전역객체이며, 생략을해도 자연스럽게 붙어있다(눈에 보이지는 않지만). 이를 암시적이라고 한다.

그렇기에 어떤 변수(전역변수라도)던 메소드이던 전역객체의 프로퍼티에 속하는 것이다.

> 전역객체의 이름은 호스트 환경에 따라서 달라질 수 있다. (nodejs 에서는 global) 

# 80강

## this: 함수와 this

this는 함수 호출 맥락을 의미한다. 즉, 고정되어 있는 것이 아니라, 사용하는 상황에 따라 그 의미가 달라질 수 있다는 걸 의미한다.

this는 함수 안에서 사용되는 키워드로, js안에서 약속된 변수이다. this는 함수에서 어떻게 쓰이느냐에 따라 값이 달라질수 있는 변수이다.











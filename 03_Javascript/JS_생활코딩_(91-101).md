# 91강 

## 표준 내장 객체의 확장: 배열의 확장 (1)

```
var arr = new Array('seoul','pusan');

// 값들중 하나를 랜덤하게 가져오는 코드를 짜보자

function getRandomValue(arr){
	var index = Math.floor(Math.random() * arr.length);
	return arr[index];
}
```
> math.floor : 소수점 아래의 수를 버리는 메소드.

# 92강

## 표준 내장 객체의 확장: 배열의 확장 (2)

91강에 작성한 코드를 수정해서 작성해보자. 배열에서 랜덤하게 하나를 얻는 함수를 만들었다.

```
// 함수가 객체안에 들어있을때의 이름의 복잡도는 다르다!
// 배열객체의 원형에 랜덤이라는 메소드를 추가한다.
Array.prototype.random = fucntion(){
	// 만들어진 배열객체 자체를 가리킨다.
	var index = Math.floor(Math.random() * this.length);
	return this[index];
}
```

실행은

`arr.random()`을 하면 된다. 위와 같은 코드는 인자가 없으니 사용자가 신경쓸 것을 덜어준다. 

> 프로토타입 확장을 통해 모든 배열이 가져야하는 API를 바꿀 수 있다는 것은 매우 매력적이다.

# 93강

## object: 오브젝트란?

object라는 이름을 가진 object가 존재한다. 편하게 말하기 위해 오브젝트 객체라고하자. 오브젝트라는 객체의 속성은 모든 객체가 가진 속성이 된다. 오브젝트라는 객체는 모든 객체의 부모다. 

즉, `object.prototype` 은 모든 객체들의 원형이 되는 것이다. 

1. 오브젝트 객체의 프로토타입은 모든 객체가 사용할 수 있는 기능이다.
2. 모든 객체가 가지고 있었으면 하는 기능이 있다면, 오브젝트의 프로토타입으로 기능을 추가하면 된다.

# 94강

## object: 오브젝트 API 사용법

[이곳을 보며 확인하자](https://developer.mozilla.org/ko/docs/Web/JavaScript)

__두가지 메소드의 차이를 보며 .prototype이 있고없고의 차이가 무엇인지 보도록하자__

`Object.keys(객체)`와 `Object.prototype.toString()` 을 사용한다.

```
// keys()
var arr = ["a","b""c"]
console.log('Object.keys(arr), Object.keys(arr));
// 0,1,2

// prototype.toString()
var o = new Object();
console.log('o.toString()', o.toString());
var a = new Array(1,2,3);
console.log('a.toString()', a.toString());
```

> prototype.toString() : 객체가 담고있는 값이 무엇인지 사람이 보기좋게 출력해주는 기능. 문자열로 출력한다.

> keys() : 키값들을 배열로 리턴하는 메소드.

__프로토타입이 있는 것__

프로토타입이 있는 것은 어떠한 객체를 만든다. 그리고 객체를 넣은 식별자에 `.`을 붙여 사용한다. `o.toString();`

메소드가 프로토타입에 속한다는 것은 new object();를 실행시키는 순간에 객체를 만들고, 우리가 호출한 생성자에 프로토타입이라는 특수한 속성에 저장된 객체를 원형으로하는 원형의 객체가 생성된다. 객체를 생성하고, 객체에 대한 메소드로서 사용하게 되는 것임.

__프로토타입이 없는 것__

`Object.keys(객체);` 처럼 인자로 어떠한 값을 받아서 생성한다. 

__정리__

오브젝트의 프로토타입이 껴있는 메소드들은 모든 객체에서 사용이 가능하다. 오브젝트 객체는 모든 객체의 조상이기 때문이다. 그렇기 때문에 모든객체가 공통적으로 가지고 있어야하는 기능이 필요하다면 오브젝트의 프로토타입을 수정하면된다.

# 95강

## object: 오브젝트 확장

어느 객체에서나 사용할 수 있는 메소드를 만들어보자 

구현할 메소드는 이것이다.

```javascript
var o = {'name':'hyun','city':'seoul'}
console.log(o.contain('hyun'));
var a = ['hyun', 'sue', 'sun'];
console/log(a.contain('sue'));
```

인자를 전달하면 인자에 해당하는 값이 객체안에 있는지 없는지를 체크하고  boolean 타입을 리턴한다.

> 자신이 만들 것이 어떻게 사용될지를 설계하고 구현하는 것이 중요하다. 

구현해보자

```
Object.prototype.contain = function(needle){
    for(var name in this){
        if(this[name]===needle){
            return true;
        }
    }
    return false; // 존재하지 않는 값.
}
```

프로타입이라는 생성자의 프로퍼티 안에 들어있는 객체를 변경한다.

# 96강

## object: 오브젝트 확장의 위험

오브젝트의 확장은 위험하며 가급적 하지않는 것이 좋다. 모든 객체에 영향을 주기때문에 신중하게 확장해야한다. 

만약 메소드를 추가하여 오브젝트를 확장했다면,  객체를 만들때마다 객체 안에 해당 메소드가 포함되기 때문이다. 

객체나 배열을 정의하는 사람은 자신의 정의한 데이터가 열거될 것이라 기대하는데, 오브젝트에 새로 추가된 프로퍼티나 메소드가 같이 열거되는 것이다.

__해결법__

`o.hasOwnProperty` 프로퍼티를 사용하면 이를 방지할 수 있다.  오브젝트가 가진 메소드이며, 모든 객체가 해당 메소드를 가지고 있다.

```
for (name in o){
    if(o.hasOwnProperty(name)){
        console.log(name);
    }
}
```

> 객체가 인자로 전달받은 값을 자신의  프로퍼티로 가지고 있는 지를 체크한다. contain은 부모로 부터 상속받았기  때문에  걸러진다.

객체의 직접적인 소유인지, 직접적으로 정의된 녀석인지를 체크하는 기능이다. 상속받은 프로퍼티와 소유하고 있는 프로퍼티를 구분할 수 있는 것이다.

# 97강

## 원시 데이터 타입과 객체

여러 데이터 타입을 어떤 기준에 따라 분류를해서, 같은 카테고리안의 유사한 부분, 그리고 다른 카테고리간의 차이점을 살펴보도록하자.

__데이터타입의 구분__

1. 원시 데이터 타입 (기본데이터 타입)

   - 숫자, 문자열, 불리언, Null, undefined

   - 객체가 아닌 데이터 타입을 원시 데이터 타입이라고 한다.

2. 객체 데이터 타입 (참조 데이터 타입)

# 98강

## 래퍼 객체

원시 데이터 타입과 객체가 서로 다르게 동작해야 효용이 있을테니, 이 과정을 살펴보도록하자.

```javas	cript
var str = 'coding';
console.log(str.length);
console.log(str.charAt(0));
```

위의 코드를 보면 문자열이 객체로 쓰인다. 분명 원시데이터라고 했는데 어떻게 된 일일까!

> `.` : Object access Operator ; 점 앞에있는 것은 객체라는 것을 알 수 있다.

문자열이 원시데이터가 맞기는 하지만, 문자열을 제어하기 위해서는 문자열이 마치 객체인 것처럼 동작해야한다. 그런 이유로 인해서 자바스크립트에서는 원시데이터를 임시로 객체로 만들어준다.

`str = new String('coding');` 과 같이 객체를 생성해 담아주는 코드가 숨겨져 있다고 보면 이해하기 쉬울 것이다. 

그렇다면 `str.prop='hi';` 와 같이 코드를 입력했다고 해보자. 결과적으로 에러가 나지는 않는다. str을 객체처럼 여기기때문에 그런 것이다. 하지만 콘솔에 str.prop를 찍어보면 undefined가 뜬다. 

prop를 할당하고 문장이 끝난 순간,  객체를 제거하고 원래의 원시데이터 타입으로 돌려놨기 때문이다. 즉, 원시데이터 타입을 마치 객체처럼 사용하려고 할 때 내부적으로 자동으로 만들어 지는 객체를 **래퍼 객체**라고 한다. 

> 원시데이터 타입을 감싸주는 객체라고해서 래퍼이다.

원시데이터는 객체처럼 사용할 수가 없는데, 래퍼 객체를 통해 객체처럼 사용할 수 있는 것이다. JS는 내부적으로 이를 알아서 해준다.

1. 숫자: Number
2. 문자열: String
3. 불리언: Boolean

# 99강

## 참조: 복제란?

전자화된 시스템에서 데이터의 복제는 아주 쉽고 빠르다. 프로그래밍에서는 복제가 어떻게 사용될까?

```javascript
var a = 1;
var b = a;
b = 2;
console.log(a); // 1
```

참조라는 개념을 잠시 미뤄두자. a에 담긴 1이 복제되어 b에 담기는 것이다. 복제된 데이터는 변경해도 원래의 데이터에 영향을 주지 않는다.

> 참조의 개념에서 보면, a가 참조하던 값이 똑같이 하나 더 만들어져 b가 참조하는 것이다.

# 100강

## 참조

변수에 담긴 값이 원시데이터 타입일 때 복제가 일어난다. 그렇다면 변수에 담긴 값이 객체일 때는 어떻게 달라질까?

```javascript
var a = {'id':1};
var b = a;
b.id = 2;
console.log(a.id); // 2
```

b의 프로퍼티를 변경했는데, a의 프로퍼티까지 변경된 것이다. 이는 객체에 대한 참조가 이루어지기때문에 가능한것이다.

원시데이터와 다르게 객체는 복제가 되는 것이아니라, 같은 객체를 참조하게 되는 것이다. 객체에 접근할 수 있는 주소 2개를 가지고 있는 것이라고 생각하면 된다. 마치 바로가기 폴더라고 보면 이해하기 쉬울 것이다.

> `b=a`를 했을 때, 객체는 변수들이 똑같은 객체를 바라보는 것이고, 원시데이터는 같은 값을 바라보게하는데 별개의 복제된 값을 바라보게 한다.

# 101강 

## 함수와 참조

```javascript
var a = 1;
function func(b){
    b = 2;
}
func(a);
console.log(a); //1
```

이 과정은, `a=1`, `b=a`, `b=2`의 형태가 된다. 즉, b에 a의 값을 복제해서 참조하게 한것이다.  복제는 서로에게 영향을 미치지 않으므로, 함수안에서 b를 바꿔도 a에 담긴 것에는 영향을 주지 않는다.

하지만 객체를 인자로 넘긴다면 어떻게 될까? 

```javascript
var a = {'id':1};
functino func(b){
    b.id = 2;
}
func(a);
console.log(a.id); // 2
```

b가 a와 같은 것을 **참조**하고 있는 것이기 때문에, a에 영향을 미친다.

> 숫자와 문자, 불리언은 원시데이터지만 래퍼객체를 통해 객체처럼 사용할 수 있다. 헷갈리지 않도록 하자.
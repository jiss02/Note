# 91강 

## 표준 내장 객체의 확장: 배열의 확장 (1)

```
var arr = new Array('seoul','pusan');

// 값들중 하나를 랜덤하게 가져오는 코드를 짜보자

function getRandomValue(arr){
	var index = Math.floor(Math.random() * arr.length);
	return arr[index];
}
```
> math.floor : 소수점 아래의 수를 버리는 메소드.

# 92강

## 표준 내장 객체의 확장: 배열의 확장 (2)

91강에 작성한 코드를 수정해서 작성해보자. 배열에서 랜덤하게 하나를 얻는 함수를 만들었다.

```
// 함수가 객체안에 들어있을때의 이름의 복잡도는 다르다!
// 배열객체의 원형에 랜덤이라는 메소드를 추가한다.
Array.prototype.random = fucntion(){
	// 만들어진 배열객체 자체를 가리킨다.
	var index = Math.floor(Math.random() * this.length);
	return this[index];
}
```

실행은

`arr.random()`을 하면 된다. 위와 같은 코드는 인자가 없으니 사용자가 신경쓸 것을 덜어준다. 

> 프로토타입 확장을 통해 모든 배열이 가져야하는 API를 바꿀 수 있다는 것은 매우 매력적이다.

# 93강

## object: 오브젝트란?

object라는 이름을 가진 object가 존재한다. 편하게 말하기 위해 오브젝트 객체라고하자. 오브젝트라는 객체의 속성은 모든 객체가 가진 속성이 된다. 오브젝트라는 객체는 모든 객체의 부모다. 

즉, `object.prototype` 은 모든 객체들의 원형이 되는 것이다. 

1. 오브젝트 객체의 프로토타입은 모든 객체가 사용할 수 있는 기능이다.
2. 모든 객체가 가지고 있었으면 하는 기능이 있다면, 오브젝트의 프로토타입으로 기능을 추가하면 된다.

# 94강

## object: 오브젝트 API 사용법

[이곳을 보며 확인하자](https://developer.mozilla.org/ko/docs/Web/JavaScript)

__두가지 메소드의 차이를 보며 .prototype이 있고없고의 차이가 무엇인지 보도록하자__

`Object.keys(객체)`와 `Object.prototype.toString()` 을 사용한다.

```
// keys()
var arr = ["a","b""c"]
console.log('Object.keys(arr), Object.keys(arr));
// 0,1,2

// prototype.toString()
var o = new Object();
console.log('o.toString()', o.toString());
var a = new Array(1,2,3);
console.log('a.toString()', a.toString());
```

> prototype.toString() : 객체가 담고있는 값이 무엇인지 사람이 보기좋게 출력해주는 기능. 문자열로 출력한다.

> keys() : 키값들을 배열로 리턴하는 메소드.

__프로토타입이 있는 것__

프로토타입이 있는 것은 어떠한 객체를 만든다. 그리고 객체를 넣은 식별자에 `.`을 붙여 사용한다. `o.toString();`

메소드가 프로토타입에 속한다는 것은 new object();를 실행시키는 순간에 객체를 만들고, 우리가 호출한 생성자에 프로토타입이라는 특수한 속성에 저장된 객체를 원형으로하는 원형의 객체가 생성된다. 객체를 생성하고, 객체에 대한 메소드로서 사용하게 되는 것임.

__프로토타입이 없는 것__

`Object.keys(객체);` 처럼 인자로 어떠한 값을 받아서 생성한다. 

__정리__

오브젝트의 프로토타입이 껴있는 메소드들은 모든 객체에서 사용이 가능하다. 오브젝트 객체는 모든 객체의 조상이기 때문이다. 그렇기 때문에 모든객체가 공통적으로 가지고 있어야하는 기능이 필요하다면 오브젝트의 프로토타입을 수정하면된다.

# 95강

## object: 오브젝트 확장

# 96강

## object: 오브젝트 확장의 위험

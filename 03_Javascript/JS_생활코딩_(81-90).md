# 81강

## this: 메소드와 this

```
var o = {
	func: function(){
		if(o === this){
			document.write("o === this");
		}
	}
}

o.func();
```

를 실행하면 "o === this"가 제대로 출력된다.

즉, 메소드가 소속된 객체를 this로 접근할 수 있는 것이다.

__정리__

함수를 호출하는 것과 객체에서 메소드를 호출하는 것은 다른 것처럼 보일 수 있으나 사실은 비슷한 맥락이다. 

함수를 호출하는 것처럼 보여도 `window.func();` 와 같이 전역객체에 속해 동작하므로, 객체에 속한 메소드를 호출하는 것과 크게 다름이 없기 때문이다.

# 82강

## this: 생성자와 this

```
var funcThis = null;

function func(){
	funcThis = this;
}

var o1 = func();
if (funcThis === window){
	documents.write('window');
}

// 함수 호출시 전역객체 window가 this에 담긴다.

var o2 = new func();
if (funcThis === o2){
	documents.write('o2');
}

// 객체가 생성자 안에서의 this가 된다.
```

생성자로 사용될 때는 this의 값이 생성된 객체가된다. 

__순서__

1. 생성자를 호출하여 객체를 생성한다.
2. 생성자의 내용을 쭉 실행한다.
3. 변수에 할당한다.

즉, 순서에 따라 아래와 같은 코드가 불가능하다.

```
function func(){
	if(o2 == this){...}
}
```

o2가 아직 변수에 담기지 않아 undefined 되어있기 때문이다.

생성자를 호출하면, 생성자가 쭉 실행되는 과정에서 객체의 이름은 정의되어 있지 않다고 볼수 있다. 생성된 객체가 아직 변수에 담기지 않았기 때문이다.

this라는 것은 생성(초기화)이 끝나서 어떤 식별자에 담기기전에 우리가 그 객체를 참고할 수 있는 식별자이므로 필수적으로 있어야한다.

> 복습: this는 생성자가 만든 객체를 가리킨다.

# 83강 

## this: 객체로서의 함수

함수는 apply와 call이라는 메소드를 가지고 있다. 

```
function sum(x,y){return x+y;}

// 와 아래의 코드는 비슷하다고 할 수 있다.

var sum2 = new function('x','y','return x+y;');
// 마지막에 등장하는 인자가 리턴값이 된다.
sum2 (1,2);

```

#### 리터럴

편리하게 어떠한 값을 만들도록 해주는 문법적인 체계

__리터럴 사용의 예__

`function sum(x,y){return x+y;}` 는 함수리터럴이라 한다.

`var o = {};` 는 객체리터럴,

`var a = [];` 는 배열리터럴이다. 

`new (object, array, function())` 의 형식으로 생성할수도 있지만 불편하니까 리터럴을 쓰는 것이다. 

# 84강

## this: apply와 call

> 객체라면 프로퍼티를 가질 수 있다.

```
var o = {}
var p = {}
function func(){
	switch(this){
		case o:
			document.write('o');
			break;
		case p:
			document.write('p');
			break;
		case window:
			document.write('window');
			break;
	}
}

func(); // window
func.apply(o); // 
func.apply(p);
```

> apply의 첫번째 인자는 함수 호출의 컨텍스트를 대입하는 것이다. 

다른언어에서의 객체는 일반적으로 메소드는 강하게 객체에 소속된다. 메소드는 다른 곳에 가지못하고 객체에 고정된다. 

그러나 js에서는 함수자체도 일종의 객체가될 수 있으며, 어떻게 호출하느냐에 따라 다른 객체에 소속될 수도있다. 객체에 소속이 되기도 하고, 객체가 되기도하는 것이다.

__이런 이유로, 자바스크립트는 유연하다고 할 수 있다.__

# 85강

## 상속: 상속이란?

객체는 하나의 컨테이너고 그 안에는 작업과 관련된 변수와 메소드가 모아져있다. 그런 객체의 특성으로 인해 객체의 특성을 물려받아 새로운 객체를 만들 수 있다. 

이럴 때 원본 객체는 부모이고, 객체의 특성을 그대로 물려받아 만든 새로운 객체는 자식이라고 한다.

이를 상속이라하며, 상속을 통해 필요한 메소드나 변수는 추가하고 필요없는 것은 버리며 로직을 재활용할 수 있다는 장점이있다.

__객체 prototype__

하나의 약속된 프로퍼티인 prototype을 보자

```
function Person(name){
	this.name = name;
}

Person.prototype.name = null;
Person.prototype.introduce = function (){
	return 'My name is' + this.name;
}
```

person이라는 생성자에는 프로토파입이라는 프로퍼티가있고, 그 안에는 객체가들어가있다. 

# 86강

## 상속: 상속의 사용방법

상속의 작동 방법을 알아보자

```
function Person(name){
	this.name = name;
}
Person.prototype.name = null;
Person.prototype.introduce = function() {
	return 'My name is' + this.name;
}

// 프로그래머도 사람이므로, 사람의 생성자를 상속하도록하겠다.
function Programmer(name){
	this.naem = name;
}
Programmer.prototype = new Person();

var p1 = new Programmer('egoing');
documents.write(p1.introduce());
```

프로그래머라고하는 생성자가 가지는 특수한 프로퍼티인 프로토타입의 값으로 person 생성자를 넣은 것이다. 

person생성자에 의해 객체가 생성되는데, 생성할 때 프로토타입이라는 속성을 (부모)생성자가 가지고 있는지 확인한다. 그리고 그 생성자 함수의 프로토타입 속성 안에있는 변수와 메소드를 똑같이 만들어서 객체를 전달해준다.

이렇게 부모로부터 객체가 생성되어 상속받는 객체의 프로퍼티 속성안으로 들어가는 것임.

> 어떠한 객체를 상속받고 싶다면 그 객체를 생성자의 프로토타입에 할당시키면 된다.

# 87강

## 상속: 기능의 추가

그렇다면 어떻게 상속받은 객체의 기능을 추가할 수 있을까?

```
function Person(name){
	this.name = name;
}
Person.prototype.name = null;
Person.prototype.introduce = function() {
	return 'My name is' + this.name;
}

// 프로그래머도 사람이므로, 사람의 생성자를 상속하도록하겠다.
function Programmer(name){
	this.name = name;
}
Programmer.prototype = new Person();
// programmer 생성자만 가지는 coding이라는 기능 추가
// 프로그래머 생성자만 가져야하므로 아래와 같이 작성해야 한다.
Programmer.prototype.coding = function(){
	return "hello world";
}

var p1 = new Programmer('egoing');
documents.write(p1.introduce());
documents.write(p1.coding());

```

디자이너 생성자를 추가해보자.

```
function Designer(name){
	return 'My name is' + this.name;
}

// person 상속받고 기능추가.
Designer.prototype = new Person();
Designer.prototype.design = fuunction(){
	return "hello design";
}
```

Programmer와 Designer는 Person의 생성자를 상속받아 각각에 맞는 기능을 추가했다.

> prototype 은 자바스크립트에서 매우 중요하며 그렇기 때문에 prototype-based 언어라고도 하는 것이다.


# 88강

## 프로토타입: 프로토타입이란?

> prototype: 원형; 자바스크립트를 다른 객체지향 언어와 구분짓는 중요한개념

__상속을 계층적으로 받는다면?__

부모에 정의된게 없다면 부모의 부모로 가서 해당한는 것이 있는지 찾는다.

__생성자의 역할__

생성자는 기본적으로 함수이다. 함수 앞에 new를 붙여주면 생성자가 되며, 새로운 객체를 만들어서 객체를 리턴하여 변수에 할당하게 된다.

> 객체가 기본적으로 갖춰야하는 변수나 메소드를 제공하므로 빈 객체를 생성하는 것보다 유용하다.

#### 프로토타입

우리가 얻고자하는 객체의 원형(어떤 메소드와 어떤 프로퍼티를 가지고 있는지)을 어딘가에 저장해야하는데, 이를 프로토타입이라는 프로퍼티에 저장하는 것이다.

프로토타입이라는 특수한 프로퍼티안에는 객체가 정의되어있다. 생성자를 호출하면 생성자 함수의 프로토타입에 저장된 객체를 꺼내서 리턴을 해주게 된다.

# 89강

## 프로토타입: prototype chain

> 서로가 서로를 연결하는 관계

__주의할 점__

```
function Ultra(){}
Ultra.prototype.ultraProp = true;

function Super (){}
Super.prototype = new Ultra;

function Sub(){}
Sub.protptype = new Super();
```

위와 같은 코드가 있을 때 `Sub.prototype = Super,prototype;`을 사용하지는 말자. 이렇게 하면 멀쩡히 돌아가는 것처럼 보인다.

그러나 위와같이 정의한 후 서브의 프로토타입에 있는 어떠한 객체에 다른 값들을 주게되면 super의 프로퍼티에 영향을 주기때문에, 하위 객체의 변경이 부모 객체의 변경이 되는것과 동일해지는 것이다.

> 자식에게 일어나는 일이 부모에게도 일어날 수도 있기 때문에, 부모의 프로토타입을 사용하지 말고, 만들어진 복제본을 사용하도록하자.

# 90강

## 표준 내장 객체란?

자바스크립트가 기본적으로 가지고있는 객체들을 의미한다.

> Standard built in object

1. Array
2. Object
3. Function
4. String
5. Boolean
6. Number
7. Math
8. Date
9. RegExp

JS를 이용하는 호스트환경에따라 다른 객체들이 추가될 수 있다.

사용자가 직접 정의해서 사용하는 객체는 **사용자 정의 객체**라고 한다.

이런 사용자 정의 객체와 표준 내장 객체를 연결해서 사용할 수도 있다

> 표준 내장 객체에 필요한 것을 추가하여 사용하는 것을 의미한다.

  
## JSON

자바스크립트 객체로서 수행할 수 있도록 하는 가벼운 문자열 데이터 표현식. 가벼운 상자정도로 보면된다.



## REST

기존의 서버에서는 HTML과 CSS, 그리고 JS를 주고 받는다. 하지만 REST에서는 딱 데이터만 주고 받는다. 스타일이나 로직 없이 요청과 응답만 담은 의사를 전달한다.

기초 과정은 요청을 보내고 html을 렌더링했다면, 중급에서는 REST라는 API 서버를 만들어 두고 JSON에 다가 요청에 따른 응답을 만들어 담고 보내주는 과정에 집중해야한다.



## 직렬화

JSON으로 표현된 것은 컴퓨터에게 애매하다. 이게 JS 객체인지 아닌지를 어떻게 구분한단말인가! 이런 고민을 해결하기위해 표현하고자 하는 데이터를 만국 공통 자료형인 `문자열`로 바꾸어 보내게된다. 이가 바로 **직렬화**이다.

> 네트워크 구성상의 메모리 문제도 있다.

사용자는 객체를 문자열로 바꾸어 서버로 보내고, 서버는 문자열을 객체로 바꾸어 사용자에게 보내게 된다.

```python
"""diary == 딕셔너리 데이터"""
dict_s = json.dumps(diary)
print(type(dict_s))

## ==> str
```



## Http Request & Response

 Restful API 가 http 프로토콜 기반의 작동방식이므로 천천히 복습하도록 하자.

 서버는 사용자에게 request 받은 정보를 잘 가공해서 처리하는 역할을 한다. 이때 웹상에서 통신을 수행할 수 있게 해주는 규약을 **HTTP**라고 하는데, 장고에서 지원하는 HTTP 프로토콜 메소드에는 크게 2가지가 있다. 바로 GET과 POST이다.

### GET

- '가져다 줘!' == > 내가 get방식으로 요청하면 폼을 가져다줘!
- URL에 입력 데이터가 뜬다.

### POST

- '처리해 줘!' == > 내가 폼에입력한 정보를 처리해줘!
- URL에 뜨지 않는다.

### DJANGO Rest framework의 메소드

GET

요청받은 url 정보 검색후 응답한다.

POST

요청된 자원을 생성한다.

PUT

요청된 자원을 수정한다.

> 전체를 갱신해 달라는 것이다.

DELETE

요청된 자원을 삭제한다.

PATCH

요청된 자원의 **일부**를 수정한다. (교체)

OPTION

웹서버에서 지원되는 메소드의 종류를 확인한다.

### 정리

장고는 본질적으로 웹어플리케이션을 만들기위한 수단이기 때문에, 네트워크 상에 html, css, js가 떠다닌다. 하지만 rest framework는 api서버로써 http 프로토콜 기반의 통신이기 때문에 JSON 파일이 날아다닌다.

응답또한 JSON으로 날아가게 된다. 그러므로 응답코드도 알아두도록하자!  



## Httpie

Rest API 서버에 대한 구조나 설계 방법을 알아보기 전에, 클라이언트(사용자)에게 Request를 받아 이에 걸맞는 JSON response를 보낸다는 것을 명심하자.

Httpie는 이런 요청과 응답을 커맨드 라인으로써 구현하는 파이썬 기반의 프로그램이다. 정확히는, **커맨드 라인으로 동작하는 http client이다.** httpie 뿐만 아니라 다른 http client도 다양하게 존재한다. 

### Httpie 명령어

명령어는 http로 시작한다.

```
http [flags] [method] URL [ITEM [ITEM]]
```

- flags: 옵션.

- method: http 메소드.

- url: 요청이나 응답의 대상.

- item: 어떤 값을 처리해줘! 라고 할때 보내는 **인자**.

  > GET의 경우 `==` , POST나 PUT의 경우 `=`로 넘겨주 면 된다.


__요청 방식__ (옵션)

1. Json 형식의 요청 `--json`
2. HTML form 형식의 요청 `--form`

### shell에 입력하는 명령어

```python
# 헤더만 보여준다
http --header GET "example.com"

# 응답을 간단히 테스트 하기위한 도메인에 GET요청
http GET httpbin.org/get x==1 y==2

# 포스트 요청
http --form POST 'httpbin.org/post' x=1 y=2
```

### 폼형식과 JSON방식의 차이

__--form__

기본적으로 html에서 form으로 전송하는 것과 같다. 응답 헤더를 보면 데이터가 form에 담겨 전송이 되는 것을 확인 할 수 있다.

__--json__

보내지는 데이터 전체가 문자열로 데이터를 주고 받는다. API 서버와 통신을 할 때에는 문자열로써 데이터를 주고받는 다는 것이 확인되는 것이다! 

>  json형식으로 요청을 보냈기 때문에 문자열로 주고 받아 지는 것이다.

  

## CBV - Class based View (Generic view)

클래스를 기반으로 한 뷰를 의미한다. 클래스를 통해 상속을 용이하게하고 코드의 중복을 줄여보자.

> 호출이 가능한 객체: 함수, 클래스

**왜 redirect가 아닌 reverse_lazy 인가?**

장고에서 제공하는 클래스 기반을 상속받아 사용하는 것이므로 이를 준수해주어야한다.

리버스 레이지는 리다이렉트와 같은 역할을 하며, 리다이렉트는 return 을 해주어야하지만, 클래스기반의 경우 리버스 레이지를 사용하여 success_url 변수에 무조건 담아주어야하는 것이다.

다른 좋은 함수들은 다음에 따로 다뤄보도록하겠다!

**Create시 다른 작업을 하고싶다면?**

상속이므로 클래스 밑에 함수를 쭉쭉 정의해주면 된다.

### CBV (1)

__왜 굳이 클래스인가?__

__함수로 작성한 것과 무슨차이가?__

클래스에만 존재하는 개념, **상속**때문에 클래스를 사용한다! 중복의 제거와 코드의 재사용에 매우 용이하기 때문에 클래스로 작성하는 것이다. 그러나 코드가 간단해지는 만큼 미리 약속된 규칙들이 있으니 이를 잘 숙지하도록하자.

__Views.py 무엇으로  채워넣어야 하는가?__

view는 함수와 클래스 모두 작성이 가능하며, 함수와 클래스는 서로 뿌리를 공유한다. 바로 함수와 클래스 모두 호출가능한 대상이라는 점! 즉, 장고의 view는 사실 callable object로 정의 가능하다는 것이다.

> 내가 커스터 마이징 하는 비중이 많은 경우 함수기반을 사용하는 것이 좋다.

### CBV (2)

__함수기반에서의 url 예시__

```
path('', views.BlogView.as_view())
```

두번째 인자에 as_view()가 붙은 것으로 미루어보아 BlogView가 클래스라는 것을 알 수 있다! 해당 클래스에 속한 기본 메소드라는 것이다. 이 메소드는 디폴트로 저장된 것이며, 우리가 상속을 받은 것이다.

__as_view()의 필요성__

장고의 path는 `url의 이름, 함수, url path name` 을 인자로 받는데,  제너릭 뷰를 사용하면 두번째 인자로 함수가 들어가야하는 상황이다. 클래스가 들어가게되면 path 형식에 맞지 않으니 이를 함수로써 표현해주기위해 as_view() 를 사용하는 것이다.

### CBV (3)

그렇다면 폼이나 객체들을 띄울 html은 어떻게 만들어야할까? 물론 이 또한 규칙에 따라 만들어 주어야하며, 마음대로 html 이름을 지으면 안된다. 

```
(소문자모델명)_list.html
(소문자모델명)_form.html (create와 update모두)
(소문자모델명)_detail.html
(소문자모델명)_confirm_delete.html
```

__html 이름을 바꿔주고 싶다면?__

클래스에 이렇게 넘겨주자 `template_name = 'classcrud/nameyouwant.html'`

__object_list__

지정한 클래스(모델)로 만들어진 모든 객체들의 목록. 자동으로 해당 모델의 모든 객체들이 위의 이름으로 담긴다.

__object__

지정된 pk값에 맞는 객체 (detail 페이지로 들어갈때 pk에 해당하는 객체가 object라는 이름에 담기는 것이다).

__그럼 서로 다른 객체 목록을 어떻게 구분할 것인가?__

디폴트로 만들어진 이름이 object, object_list 라면 어떻게 구분할 것인가? 

아주 간단하다! 클래스에 이렇게 넘겨주면 된다.

`context_object_name = 'anything_name'` 
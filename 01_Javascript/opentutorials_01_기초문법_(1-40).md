# 1강

## JS 오리엔테이션

### JS란

JS라는 언어는 웹브라우저라는 형태의 웹브라우저로 분류된 소프트웨어들을 프로그래밍적으로 제어하기 위한 언어이다.

JS는 프로그래밍적으로 웹브라우저를 제어하기 위한 도구라고할 수 있다.

### 프로그래밍적 제어란

코드를 브라우저에게 제출하면 하나하나 해석해서 띄워주는 것이다.

즉, 프로그래밍적이란 것은

Ex. 경고창이라는 기능을 JS의 코드를 통해서 제어하는 것 

### 탈웹브라우저의 흐름

자바스크립트가 더이상 웹브라우저를 제어하는 것에만 사용되지 않는 다는 것이다.

탈브라우저화가 되면서 JS와 JS가 동작하는 환경을 분리하여 생각할 필요가 있다.

웹서버를 동작하기 위한 도구로 사용이되는데 이를 서버사이드 스크립트라고한다. 브라우저에서 작동되는 것은 클라이언트 스크립트라고 부른다.

#### 서버와 브라우저의 흐름

사용자가 주소를치면 주소에 해당되는 컴퓨터를 찾아가게 된다. 웹브라우저가 어떤 정보가 필요한지 요청을 하게되고, 웹서버라는 소프트웨어는 사용자가 요청한 정보를 찾아서 웹브라우저에 응답해준다.

웹브라우저에 응답하기위한 정보를 프로그래밍저그로 생성해주는 기술들이 바로 php, python,js등의 언어이다.

최근 각광 받는 것이 바로 Node.js

웹서버를 제어하는 기술이라고 요약할 수 있다.

JS문법에 따라서 Node.js 라는 기술을 제어하는 것이다. 

### 탈웹

웹에서 사용되던 JS가 웹 이외에서도 사용되기 시작했다. Google apps script에서도 쓰이기 시작한 것이다. 

#### 언어와 환경

JS 언어

__~('hello world');__

이를 기반으로한 환경

__웹브라우저: alert__

__웹서버: write__

__spreadsheet: msgbox__

즉, 문법 자체는 JS의 문법을 쓰되, **환경에 따라 다른 명령어**를 주어야한다.

### 정리

사용자의 입장에서 서버나 브라우저, 구글시트를 제어한다는 것은 단순히 버튼을 클릭하는 것과 비슷한 일이다. 

개발자가 된다는 것은 code를 통해 제품들을 제어하게 되는 것이다. 제품을 제어하게되면 우리만의 소프트웨어가 만들어지고 이는 최정적으로 일반 사용자, 버튼을 클릭하는 사용자가 사용하게 되는 것이다. 

# 2강

## 코드작성과 실행

자바스크립트는 html위에서 동작한다.

```
<script>
	alert('Hello world');
</script>
```

script 태그 안에서는 js의 문법을 따르는 것이다. 

# 3강

## 콘솔 사용법

개발자 도구에 대한 메뉴를 한번 보는 것이 좋다. 

화살표 위 버튼을 누르면 예전에 썼던 코드를 다시 쓸 수 있다. 

```console.log();``` 코드를 사용하면 콘솔창에 괄호안의 내용을 띄워준다.

# 4강

## 도구의 선택

__통합개발도구__

여러가지 개발에 필요한 도구를 다 가진 도구. 즉, ```IDE```라 부른다. 기능이 많다고 무조건 좋지는 않다. 무겁거나 비쌀 수도 있고, 가진 기능을 다 외워야하기때문이다. 

__도구에 대해서__

프로그래밍을 하는 것은 도구를 만드는 것이며, 프로그래밍을 할 때 좋은 도구를 사용하는 것도 중요하다.

개발할 때 어떤 도구를 써야할지 진지하게 고민하는 것이 중요하다. 좋은 개발도구를 선택한다는 것은 좋은 코드를 짜는 것 만큼이나 중요하다. 

# 5강, 6강

## 수의 표현과 수의 연산

- 정수: 딱 떨어지는 수
- 실수: 소숫점 

## math 함수

```math.ceil();```: 가까운 위의 수로 올림

```math.random();```: 0 ~ 1 사이의 난수 생성 ==> 리턴값은 숫자

# 7강

## 문자

"abc": 문자들의 집합이라하여 문자열이라 한다.

__escape__

```\```를 넣어 본래의 역할에서 탈출시키는 것.

Ex.```'hyun\'s'```

# 8강

## 문자에 대한 명령들

- "" + "": 가능.
- "" + " " + "": 문자사이에 공백 삽입.

__str 관련 기능__

```str.length```: 문자열의 길이 정수로 리턴.

```str.indexOf("chr");```: 문자열에서 해당 문자의 인덱스를 알려준다.

# 9강 

## 변수

담긴 값은 언제든 변할 수 있다. 그래서 변수라 부른다. 값을 담는 하나의 그릇이라고 보면 된다. 문자와 숫자 모두 가능하다.

```var a = 1;```

과 같이 변수 선언 가능.

var => 변수를 선언한다고 말하는 것임.

var는 생략이 가능한데.. 뒤에서 배우도록 하자.

처음 변수를 사용할때는 var를 붙여주어야 하지만, 한번 선언을 했으면 그 다음부터는 붙이지 않아도 된다. 

# 10강

## 변수의 효용

변수는 코드의 재활용성을 높여준다. 유지보수하기가 쉬워진다. 

# 11강

## 주석

```//``` 을 사용하면 주석을 달 수 있다. 코드부분이 아니며 인식하지 않는다.

```/* comment */```을 사용하면 여러줄 주석이 가능하다

# 12강

## 줄바꿈과 여백

```;```을 꼭 사용하지 않아도 되지만, 명시적으로 사용해주는 것이 좋다.

# 13강 

## 비교: 연산자란?

대입연산자(=)를 통해, 변수에 상수를 담는다고 간단하게 생각하면 좋다.

__비교연산자__

boolean 타입이 리턴된다.

```>,<,==, =>, =<```이 해당된다.

# 14강

## == 와 ===

`==`: 동등연산자. equal operator. 좌항과 우항을 비교해서 bool타입의 값으로 치환된다.

`===`: 일치연산자. strict. 엄격한동등연산자. 좌항과 우항의 값이 정확하게 같느냐를 보는 것이다. 

Ex. 1==="1": False <br>
Ex. 1=="1": True

즉, 일치연산자(`===`)의 경우 데이터의 형식까지 정확하게 같아야 한다는 것이다.

프로그램이 커질 수록, 데이터는 엄격하게 다뤄야하므로 `===`를 사용하는 것이 좋다. 같은 데이터 타입일 때만 true!

# 15강

## === 를 사용하자!

`null`: 값이 없다.

`undefined`: 값이 정의되지 않았다. 

둘을 == 로 비교하면 True가 나오고, === 로 비교하면 False가 나온다. 

null 은 프로그래머가 의도적으로 지정한 상황, undefined 는 프로그래머가 의도하지 않은 상황. 둘은 엄연히 다르다.

### boolean

- true == 1 // 참
- true === 1 // 거짓

1 이외의 수는 false 이다.

```NAN```: 계산할 수 없다. nan과 nan을 일치연산자로 비교하면 false가 나온다. 

# 16강

## 부정과 부등호

!= 은 같지 않다는 뜻이다. !== 는 === 과 비슷한 맥락이며, 정확하게 같지 않다는 것을 의미한다. 

# 17강 

## 조건문이란

boolean 과 떨어질 수 없는 관계.

__기본형태__

`if(bool){}`: 괄호안에있는 bool이 true 여야 실행이된다. 

# 18강

## else, else if

`
if(bool){}
elseif(bool){}
else{}
`

> if 괄호의 bool이 false면 elseif를 사용하고, 여기서도 false면 else를 실행한다. true인 elseif가 나오면 해당 문장만 실행하고 뒤의 코드는 전부 건너뛴다.

# 19강

## 조건문의 응용

`prompt('text);`: 사용자에게 무언가의 값을 받아낼 수 있는 함수이다. 사용자가 입력하면 들어오게 된다.

`alert(prompt('당신의 나이는?'));`

프롬프트 창을 띄우고 값을 받은뒤, 알림창으로 입력한 값을 보여준다.

# 20강

## 논리연산자

&&와 ||가 존재한다. 

- &&: and
- ||: or

# 21강

## boolean의 대체제

__1과 외의 수__

- 숫자 1은 JS에서 true로 간주된다 (-1도 true). 1 이외의 수는 False로 취급한다.

> true == 1 의 결과는 true로 나온다.

하지만 숫자로 치환해서 쓰는 것은 그리 좋지 않으니 TF로 사용하도록 하자.

__''와 !''__

JS에서 '' (빈문자열)은 F로 간주한다. !'' (문자가 있는경우) T로 간주한다.

__undefined__

false로 간주된다. 

__변수__

변수에 어떤 값도 넣어주지 않으면 undefined 상태가 되는데 이는 F로 간주한다.

이외에 Nan과 null도 false로 간주한다. 

# 22강

## 반복: 기본문법

컴퓨터는 반복적인 작업을 매우 잘한다. 그것도 실수없이!

반복: loop, iterate

__while__

`while(조건 bool){반복할 코드}`

참 값인 동안에 계속 반복한다. 

# 23강

## 반복조건

반복문을 언제까지 실행할 것이냐? 에 대한 것이다. 

# 24강

## for문

초기화와 반복조건, 그리고 증감을 한줄의 코드로 넣을 수 있어 편리하다. 

`for(초기화;반복조건;증감문)`의 형태로 이루어진다. 변수 i가 다른 곳에서 쓰여 큰일날 일이 없다. 

__for 실행 순서__

초기화 -> 반복조건 확인 -> 코드실행 -> 증감문 -> 반복조건 확인 -> 코드실행 -> ...

__전위연산자와 후위연산자__

- i++ : 후위 연산자. 변수를 1씩 증가시키는데, i++가 속한 코드를 사용한 후, i를 증가시킨다는 것이다. (기존의 i값을 사용하고 i를 증가시킴)
- ++i : 전위 연산자. i를 먼저 1 증가시킨후, ++i가 속한 코드를 실행한다. 

# 25강

## 반복문의 효용

수많은 문장을 하나하나 코딩하고 이를 수정하는 것은 쉽지 않다. 사람은 실수하기마련이기 때문이다. 반복적인 부분을 반복문으로 사용한다면, 유지보수가 쉽다. 

# 26강

## 반복문의 제어

중간에 중단시키고 싶다면 어떻게 해야할까?

__break__ 를 사용하자! 

예를들어, `if (i===5){break;}` 와 같은 형태를 반복문 안에 넣는 것이다. break를 만나면 가까운 반복문을 종료한다. 

__continue__

`if (i===5){continue;}`의 형태로 사용되며, 반복문 안에 넣는다. continute를 만나면 continue 뒤의 코드를 전부 무시하고 증감문으로 되돌아간다. break는 반복문의 완전한 종료, continue는 일시적인 반복문의 종료라고 보면된다. 

# 27강

## 반복문의 중첩

```
for(){
	for(){
	}
}
```

와같은 형태를 중첩이라 한다. 

### 디버그

디버그를 통해 한줄씩 실행해 볼수 있다.

# 28강

## 함수란?

함수는 하나의 로직을 재실행 할 수 있도록 하는 것으로 코드의 **재사용성**을 높여준다. 

### 함수의 형식

```
fuction 함수명(인자){
	코드
	return 반환값
}
```

의 형태로 함수를 정의한다. 

```
fuction numbering(){
	var i = 0;
	while (i<10){
	document.write(i+'<br />');
	i += 1; 
	}
}
```

__사용법__

`함수이름();`

만약 괄호가 없다면 js는 변수로 인식 할 것이다. 

함수를 실행하면 정의된 함수들중에 있는지를 찾는다.

# 29강

## 함수의 효용

0~9까지 작성하는 코드를 5번 반복하라고 했다고하자. 함수를 사용하지 않으면 같은 코드의 반복문을 5번 반복해야한다. 코드가 쓸데없이 길어지는 것이다. 

하지만 함수를 사용하면 더욱 용이해진다. 변경사항이 있으면 5번 수정해야하지만 함수를 사용하면 정의된 함수만 변경해주면 되기 때문이다.

함수는 필요한 맥락에서 반복적으로 호출할 수 있다는 장점이 있다.

__즉, 재사용성이 있다는 것! 하나의 좋은 부품을 만드는 것이다.__

- 수정, 변경, 그리고 개선을 쉽게 만든다. 정의된 부분만 변경하면 되니까!
- 코드읽기(가독성)가 좋아진다.

프로그램이 커지면 커질 수록 코드가 복잡해지기 때문에 함수는 매우 필수적인 것이다. 함수라는 것은 하나의 좋은 부품을 만드는 것이다.

# 30강 

## 함수: 출력

함수는 하나의 상자다!

입력에 따라 출력이 달라지는 것이 function이다!

### 출력

__return__

return이 등장하면

1. 함수를 종료시킨다
2. 값을 출력값으로 반환한다.

retrun이 여러개라면, 첫 리턴의 값만 반환이된다. 리턴이 나오자마자 종료되기 때문이다.

# 31강

## 함수: 입력

```
function get_arg1000(arg){
	return arg*1000;
}
```

arg는 파라미터이며, 변수이다. 

예를들어, `get_arg1000(2);`이며 2는 arg에 담긴다.

위의 예제를 기반으로 개념을 나누자면, 

- arg : parameter; 매개변수
- 괄호안에 들어가는 값: argment; 인자

### 복수의 인자

인자는 여러개가 들어가는 것이 가능하다

```
fuction get_arg(arg1, arg2){
	return arg1 + arg2;
}
```

# 32강

## 함수의 다양한 정의 방법

`변수 = function () {return}` 의 형태로 함수를 정의할 수 있다. 변수가 함수를 담고있게 되는 것임.

__익명함수__

```
(function () {return})();
```

함수를 정의하자마자 바로 쓰는 것이다. 이름이 없어 익명함수이며 일회성호출하는 경우 사용한다. 

js는 함수형 언어라고 할 정도로 함수가 차지하는 위상이 매우 높다고 할 수 있으니 잘 알아두자.

# 33강

## 배열

연관된 데이터를 모아서 통으로 관리하는 데이터 타입이다. 변수가 하나의 데이터를 저장하기 위한 것이라면 배열은 **여러개의** 데이터를 하나의 변수에 저장하기 위한 것이라고 볼 수 있다. 

```
var member = ['영희','철수','민희']; 
```

alert(member); 을 사용하면 콤마로 원소를 구분하여 알림창을 띄워준다. 

배열안의 데이터 하나하나는 원소라고 하며 영어로는 element이다. 

배열의 인덱스(고유한 식별자)는 0부터 시작한다. 

`member[index]`의 형태를 사용하여 인덱스에 해당하는 원소를 꺼낼 수 있다. 

# 34강

## 배열의 효용

__배열이 없다면?__

함수는 여러개의 입력을 받을 수 있지만 하나의 값만 리턴(출력)이 가능하다. 이런 함수의 한계를 극복할 수 있는 것이 배열이다. 배열이 없다면? 하나씩 리턴값을 주어야하므로 원소 수 만큼 함수를 만들어야할 것이다.

# 35강

## 배열과 반복문의 조우

반복문과 배열은 아주 긴밀한 관계를 가진다. 

```
function mem(){
	return ['a','b','c']
}

member = mem();

for(var i = 0; i < member.length; i++){
	document.write(member[i].length.toUpperCaxe()+"<br />");
} 

```

반복문이 없다면 한줄한줄 코드를 작성해야 했을 것이다! 원소의 수에 따라 탄력적으로 변경이 가능해진 것이다. 

> str.toUpperCase(); 는 대문자로 바꿔주는 함수다. 

> 배열.length; 는 원소의 개수를 반환한다.

# 36강

## 배열의 제어: 데이터 추가

`array.push('something');` 명령어를 통해 배열 뒤에 새로운 원소를 추가할 수 있다. 

만약 여러개를 넣고 추가하고 싶다면, `arr.concat(['s','t']);` 명령어를 사용하면 된다. concat의 인자는 배열이어야한다.

뒤가 아닌 배열의 앞에 원소를 넣고 싶다면,
`arr.unshift('a');` 명령어를 사용하면 된다.

배열의 어딘가에 낑겨넣고 싶다면,
`arr.splice(indew, howmany, el1, ..., elN); ` 명령어를 사용하면 된다.

- splice(어디에 넣을지에 대한 인덱스,index에서 제거될 원소의 수, index+howmany 사이에 추가될 원소)
- howmany에 특정 값을 넣으면 인덱스부터 howmany 개수만큼에 해당하는 원소들은 삭제된다. 0이면 어느 원소도 삭제되지 않는다.

> splice는 삭제되는 원소를 배열의 형태로 리턴해주는 기능도 있다. 

# 37강

## 배열의 제어: 제거와 정렬

__첫번째 원소 삭제하고 싶을때__

arr.shift();

__뒤의 데이터 제거__

arr.pop();

### 정렬 

정렬은 매우 중요하다! 얼마나 빠르게 정렬하느냐에대한 논의가 많이 이루어지는데 이는 나중에 보도록 하자.

arr.sort();

를 사용하면 정렬을 해준다. 만약 역순으로 하고싶다면,

arr.reverse();

를 사용하면 된다. 

해당과 같은 정렬 함수는 JS에서 자체적으로 가지고 있는 정렬방식을 사용한 것이다. 

# 38강 

## 객체: 객체의 문법

영어로는 **Object** 이다. 배열과 유사한 역할을 하지만 다르다. 연관된 데이터를 담아내기위한 그릇이라는 점에서 유사하지만, 객체의 경우 인덱스의 값으로 숫자나 문자 등 사용자가 원하는 데이터로 인덱스를 설정할 수 있다. 가시적인 차이는 일단 여기까지 설명하겠다!

### 객체에 해당하는 것들

1. 맵
2. 연관배열
3. 딕셔너리

객체지향이라는 패러다임과 중요하게 연결되는데, 일단 데이터를 담는 컨테이너로 간단하게 생각하자. 객체 지향에 대한 설명은 뒤에서 설명한다.

### 객체의 생성

객체는 중괄호로 시작해서 중괄호로(`{}`) 끝난다.

```
var score = {'math':90, 'eng':75};
```

> 변수에 담아서 언제든 제어할 수 있도록하자.

여기서 math나 eng는 **key** 이고 90이나 75는 **value** 이다.

__객체에 원소 추가__

```
var grades={};

grades['math']=75;
grades['eng']=90;

```

또는 new Object() 를 사용하여 생성할 수도 있다.

```
var grades= new Object();

grades['math']=75;
grades['eng']=90;

```

__객체 접근__

`obj[key값]`의 형태로 입력하면 해당 키에 해당하는 value를 얻을 수 있다.

- grades['math'];
- grades.math;
- grades['ma'+'th'];

전부 같은 의미다.

# 39강 

## 객체: 객체와 반복문의 조우

배열은 저장된 데이터들이 순서를 가지고 있다. 먼저 들어간 것과 나중에 들어간 것이 기록되는 것이다. 집어넣은 순서대로 끌어올 수 있는 것이다.

그러나 객체는 순서가 없다. 키가있고 밸류가있을 뿐이다. 저장된 순서가 없기 때문에 순서가 없다고 생각하고 객체를 다루도록 하자.

```
var score = {'math': 60, 'eng':40 ,'history': 90};

for(key in score){
	document.write("key : " + key + "value: " + score[key] + "<br />");
}

```

__for a in Object__

객체 안에 있는 것을 하나씩 가져와 a에 담는다. 객체의 키와 밸류 전체를 담는 것이 아니라 객체의 키를 담는 것이다. 객체의 원소를 하나씩 가져오며 반복한다.

배열에서도 for in 을 사용할 수 있다.

```
for (index in arr){
	console.log(arr[index]);
}

```

> console.log(); 콘솔창에 보여줍니다.

__팁: HTML 리스트를 JS를 통해 만들어보자__

```
for(key in score){
	document.write("<li>key : " + key + "value: " + score[key] + "</li>");
}

```

이렇게 앞과 뒤에 li 태그를 넣어주면 된다.

# 40강

## 객체: 객체지향 프로그래밍

객체에 담길 수 있는 값는 무엇일까.

```
var grades = {
	'sam' : {'math':90, 'eng':75}
	'show' : function(){alert('hello');}
}

```

만약 샘의 수학점수가 보고싶다면 `grades['sam']['math']` 와 같이 접근하면 된다.

js에서는 함수도 일종의 값이며 저장이 될 수 있다.

__this__

this는 약속된 변수로, 함수가 속한 객체를 가르키는 변수이다.

```
var grades = {
	'sam' : {'math':90, 'eng':75}
	'show' : function(){
		for (name in this.sam){
			console.log(name, this.sam[name]);
		}
	}
}

```

여기서의 this는 함수가 소속된 객체 grades를 가리킨다. this.sam 이면, grades의 'sam'을 의미하는 것이다.

> 객체에 소속된 함수를 호출할때는 grades.show(); 의형태로 호출한다!

즉, 객체를 통해 연관있는 것 끼리 묶을 수 있는 것이다! 연관된 값과 함수 등.. 이런 것이 객체지향 프로그래밍이다. this와 객체의 심화적인 부분은 더 뒤에서 다루도록하자.
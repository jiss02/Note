# 0701

## ML과 DM

DM은 상관관계 분석, 현재 데이터에 대한 분석이 주 목적. 

ML은 새로운 미지의 데이터까지 예측한다. 결과가 확률로 나온다.

> 데이터를 기반으로 미래의 값 예측

DL은 인간의 뇌를 본뜬 인공신경망이다. 

(인공지능(머신러닝(딥러닝)))의 포함관계이다. 

머신러닝의 알고리즘을 구현하는 것 중 하나가 바로 DL이다.

## ML

### Regression & Classfication

__회귀__
연속적인 값에 대한 미래 예측

__분류__

로지스틱 리그레션이라는 알고리즘이 사용된다. 

데이터들의 분포를 보고 분류해보는 것이다. 

### DL

좀 더 분류가 잘 되는게 없을까하여 등장한 것이다.

직선만으로 분류는 어렵기 때문이다.

인풋들을 모아 특정식을 거치게 해서,

어떠한 기준선(쓰레쓰홀드)을 넘으면 활성화하고 아니면 비활성화한다.

### 행렬 연산과 기본 수학 개념

__시그마__
x + y + z 라는건, 각각이 독립변수 라는 것이다.

종속변수라는건 원인으로 인해 결과가 100% 나오는 것.

"반드시" 라는 말이 들어가야한다. 

예외가 존재하면 독립변수이다!

> 즉 시그마는 각각의 변수가 독립적이므로, 미분할 때 별개로 미분이 가능해진다. 각 항에 대한 연산이 상관 없다는 것이다.

개별 연산 수행 가능.

__곱하기__

로지스틱 리그레션 증명 시 한 번 쓰인다.

__행렬__

1. 산술연산
2. 행렬곱 (내적)

이미지 분석 시 이미지를 행렬로 표현가능하다.

> 2차원 행렬!

>  영상의 경우 2차원의 이미지들이 늘어져있는 것이므로 3차원 행렬.

이 행렬들을 일렬로 늘어트리게 되면 리그레션(ax+b)에 적용이 가능해진다.

## 파이썬

numpy로 생성되는 리스트는 배열이며, 행렬과 비슷하다.

python에는 데이터 조작을 편하게 하기위해 (-)인덱스가 존재한다. 

리스트에 다양한 자료형이 들어 갈 수 있다.

배열 원소의 자료형은 제한이없으며, 그 자료형에 맞게 딱딱 malloc이 된다.

__리턴값이 여러개인 경우?__

자바나 C는 여러개 넘겨 주는 것이 불가능해 각각 객체, 구조체를 만들어서 넘겨주면 된다. 

하지만 python은 리턴값을 여러개 전달 할 수 있다. 리턴되면 각 값들이 튜플로 들어온다.

### 리스트

```
c = []
c.append(100)
>> 배열도 하나의 클래스이다. append() 메소드를 사용하는 것.
```

머신러닝에서 판단결과가 true인지 false인지를 판단해서 append할 때 사용된다.

> 정확도 테스트 할 때 자주 쓰이는 것이다.

__슬라이싱__

범위를 지정하여 데이터를 뽑아내는 것이다. 

### 튜플

read only list이다. 한번 값을 정의하면 수정이 안된다.

list의 속성은 다 가지고 있다.

### 딕셔너리

orderedict이라는 객체를 사용하면 순서를 매길 수 있다.

__값의 참조?__

값의 참조는 전부 대괄호로 한다.

> `.`을 찍고 메소드를 사용한다는건, 객체(인스턴스)를 생성한것이다.

## 메소드

__.split(분리자)__

어떤 것을 기준으로 문자열을 나눌 것인가?

> 리턴은 리스트이다.

### tip 

regression과 classfication의 차이?

딥러닝의 원리? 뉴런의 원리 구현.

# 0702

## list comprehension

연속된 데이터 저장을 위해 리스트를 사용하는데,

그 내부에 for문이 도는 것

```
data = [x**2 for x in range(5)]
```

1. for문을 계산한다.
2. 계산한 것을 앞으로 보낸다.

## 함수

함수의 리턴값이 여러개인 경우 tuple의 형태로 날아온다.

### default parameter

함수 지정시 parameter에 기본값을 지정하는 것.

파라미터가 전달이 되지 않았을 때, 기본적으로 지정된 값을 사용하겠다는 의미이다.

파라미터는 오른쪽 끝에서부터 저장한다. 

파라미터를 받을 때 변수를 스택에 저장하는데, 차곡차곡 쌓아서 맨마지막 것을 꺼낸다.

그러므로 스택에는 오른쪽 끝에서 부터 채워나가는 것.

디폴트 파라미터를 주려면 오른쪽에서 부터 차곡차곡 넣어줘라.

### mutable / immutable parameter

1. mutable
   - 원래의 데이터에 변형이 일어나는 경우
   - 자의나 타의에 의해 변하는 것이다.
   - list, dict, numpy
   - 함수내에서 무언가를 그게 그대로 반영되어 변한다.
   - python에서 집합적인 형태의 데이터는 별도의 공간을 열지 않고 그대로 공유한다.
   - 함수에서 바꾸면 원본이 바뀜
2. immutable
   - 원래의 데이터에 변형이 일어나지 않음
   - 숫자, 문자, tuple
   - 함수내 들어온 것을 다른 공간에 저장함

## lamba

한 줄로 코드를 작성하는 일회용 함수.

```
lambda 파라미터:표현식
```

![1562051218222](C:\Users\olo51\AppData\Roaming\Typora\typora-user-images\1562051218222.png)

수학적 표현을 직관적으로 나타내기 위해 사용

## Class

새로운 데이터 타입이다.

1. 캡슐레이젼
   - 저장하는 모든 데이터를 클래스로 정의하겠다.
   - 클래스를 만든다는 것은 외부에서 접근하지 못하게 하겠다는 것
   - C++은 포인터가 있기때문에 이를 충족하지 못함.  
   - 아무리 보호하고 있어도 포인터가 있다면.. 삭제했을 때 죽어버릴수있다.
2. 인헤리턴스
   - 클래스 reuse
3. 폴리모피즘
   - 하나의 함수를 다양하게 사용하겠다.

---

클래스안의 메소드는 첫번째 인자로 self가 필수로 들어가야한다.

내부의 데이터를 접근하기 위해 필요하다는 것을 알려주는 것이다.

```python
class Person:
	def __init__(self,name):
		# 내가 보호할 변수 정의
		self.name = name
	def get_name(self):
		return self.name
	def set_name(self, name):
		self.name = name
```

1. 보호할 변수 정의
2. 해당 데이터를 set하거나 get할 메소드 정의하기
3. 필요한 기능 추가하기
   - 저장한 데이터를 어떻게 이용하고 접근할 것인지 등이 해당된다.

> 메모리에 생성된 객체는 하나의 캡슐화가 된다. 
>
> 1. 포인터가 없어 아무도 지울 수 없으며,
> 2. set과 get을 통해서만 접근이 가능하다.

### plus

python은 편하게 사용하기위해 기본이 public이다.

원래는 외부에서 절대 접근 못하는데 기본이 public이라 바로 접근이 가능해진다.

이를 방지하고 컴파일러만이 부르게 하도록 하고 싶다면, **private** 설정을 해주어야 한다.

방법은 `__`를 붙여주면 된다.

```python
def __init__(self, name):
	self.__name = name
	
def __work(self): # 함수에도 가능하다.
	print(name,"is working")
```

# 0703

## exception - 예외처리

__들어가기 전에..__

> 클래스를 뽑아내는 팁
>
> 1. 명사부터 뽑아보자.
> 2. 각 클래스가 가지고 있어야 하는게 무엇인지  확정지어보자. (자료형 등)
> 3. 확정지은 것을 외부에서 접근할 수 있도록 func를 정의해주자. (get과 set)
> 4. 데이터를 가지고 할 수 있는 것을 method로 나타내자.

__예외 처리__
원인을 찾는 것이 매우 중요하다.

항상 에러가 아닌 예외 상황을 뜻한다. 

잘 동작하다가 어쩌다 한 번 안되는 경우를 생각하면 된다.

>  게임하다 보면 가끔 죽는 경우!

![1562131950836](C:\Users\olo51\AppData\Roaming\Typora\typora-user-images\1562131950836.png)

__try & except 기본 형태__

```python
try:
	## Code
except Excertion as err:
	## Code
```

try 코드 실행중 예외가 발생하면, 즉시 해당하는 예외코드로 간다.

__finally__

예외에 상관없이 무조건 실행하겠다는 것이다.

```python
finally:
	print(sum)
```

__raise__

예외를 확인 하기 위해, raise를 통해 강제로 예외를 발생시킬 수 있다.

> 자바의 경우 throw이다. (try & catch 문이라 한다)

```python
if sum < 0:
    raise Exception("Sum is minus")
```

## with

어떠한 파일이 `open`이 되면, `close`가 되는 것이 원칙이다.

`f.close()` 한줄이 매우 값진데,  (하지만 적어주는 것을 계속 까먹는다)

연 파일을 닫아주지 않으면 메모리의 낭비가 생길 수 있기 때문이다.

이를 해결해주는 것이 바로 **with**구문이다!

__with 란__

명시적으로 리소스를 close() 해주지 않아도 자동으로 닫아주는 것이다.

with를 벗어나는 순간, 파일이나 세션들의 리소스를 자동으로 close시켜준다.

__예제__

```python
class MyClac:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        
    def sum_(self):
        return self.x + self.y
    
    def subtract(self):
        return self.x - self.y
    
    def multiply(self):
        return self.x * self.y
    
    def divide(self):
        try:  
            if self.y == 0 | self.x == 0:
                raise Exception("0 으로 나누기는 불가능 합니다.")
            else:
                ans = self.x / self.y
                return ans
        except Exception as err:
            print("You have a err: ",str(err))
```

클래스 내부에서는 exception을 계속 날리도록하자.

클래스를 받는 입장 쪽에서 예외처리를 하도록 시키자는 것이다.

수정할 것이 생겼을때, 클래스 내부에 있으면 원본 코드를 계속 수정해야 하기 때문이다.

```python
def divide(self):
    if self.y == 0 | self.x == 0:
        raise Exception("0 으로 나누기는 불가능 합니다.")
    else:
        ans = self.x / self.y
        
### 메소드를 부르는 곳에서 예외처리를 해야한다.

try:
    obj.divide()
except Exception as err:
    print(str(err))
```

다시한번 기억하자!

데이터 타입은 한번 정의되면 자주 수정되지 않도록 하는 것이 좋다.

**예외 처리는 메소드를 부르는 쪽에서 발생하게 만들자! 클래스 내부에서 구현하지 말자**

> 내부에서는 그냥 예외를 raise 하기만 하자

__예를 들어보면..__
아파트를 짓기 시작했다고 하자. 그런데 설계도를 보니 무언가를 빼먹었다. 하지만 이미 건물을 짓기 시작했으니 설계도를 바꿔도 소용이 없다! 그냥 짓다가 부족한 부분을 복원 공사를 할 수 밖에 없듯이, 이미 정의된 클래스 내부를 수정하지 말고, 외부에서 예외적인 문제가 발생하면 외부에서 처리를 하자.

---

__python 의 기본 문법 중 헷갈리기 쉬운 것은 다 다루었다. 이제 numpy 모듈을 보자.__

---

 ## numpy - 행렬을 위한 라이브러리

```
import numpy as np
```

로 라이브러리를 불러와보자!

__numpy로 가능한 것들__

![1562137551849](C:\Users\olo51\AppData\Roaming\Typora\typora-user-images\1562137551849.png)

__벡터__
수학적으로 1차원 배열을 얘기한다. 

__매트릭스__

가로와 세로가있는 2차원을 의미한다.

> 텐서는 높이까지 있는 경우. 즉, 3차원을 의미한다.

### numpy vs list

![1562137959823](C:\Users\olo51\AppData\Roaming\Typora\typora-user-images\1562137959823.png)

어떤 행렬을 만들고 싶을 때는 반드시 `np.array([])`의 형태로 써주어야한다.

1. 머신러닝에서 숫자, 사람, 동물 등의 인식을 위해서는 이미지 데이터를 행렬로 변환하는 것이 중요하다
2. 리스트의 경우 연산이 직관적이지 않고 오류가능성이 높다

==> numpy 사용이 필수적이다.

> 인덱스 슬라이싱 또한 가능하다!

__행렬의 크기 확인하기__

```python
array.shape
# 튜플의 형태로 나온다. 함수의 리턴값이기 때문이다.
array.shape[0] == 행
array.shape[1] == 열
```

```python
array.ndim
# array => 2
```

### 벡터

수학적 계산을 위해 np를 쓰자. 

프로그래밍의 유연성을 위해, 행과열을 굳이 구분하지 않는다. 

### reshape method (형변환)

수학적 연산을 편하게 해주기 위해 주로 사용한다.

형을 변환하거나  벡터를 매트릭스로 변경하기 위해 사용하거나,

매트릭스를 다른 형상의 매트릭스로 변경하기 위해서 사용한다.

```python
A = np.array([1,2,3])
A.reshape(3,1)
# [[1],[2],[3]]
A.reshape(1,3)
# [1,2,3]
```

### 행렬곱

np는 행렬곱을 가능하게 해준다.

```python
a = np.array([[1,2,3],[4,5,6]])
b = np.array([[-1,-2],[-3,-4],[-5,-6]])

c = np.dot(a,b)

print(a.shape, b.shape, a.ndim, b.ndim, c.shape)
print(c)
```

```
# 결과창
(2, 3) (3, 2) 2 2 (2, 2)
[[-22 -28]
 [-49 -64]]
```

행렬 데이터는 입력 크기에 무관하게 계산을 하기위해 사용한다.

6 x 6 = (6x14) ●(14x345)●(345x6)

데이터는 크기가 각양각색인데 각 데이터에 맞는 행렬을 전부 준비할 수 는 없다.

그러므로 기능마다 적당한 크기의 행렬을 몇개 만들어 놓고,

데이터가 들어왔을 때 가장 비슷한 사이즈를 뽑아 리사이즈 하여 행렬곱을 한다.

> 행렬곱이 없다면 모든 이미지 크기에 대해 행렬을 만들어야할 것이다.

__덧셈의 의미__

덧셈으로 이어져있다는 것은 바로, 서로 독립적이라는 것이다.

__곱셈의 의미__
데이터를 그대로 보내던지, 데이터를 없애던지, 데이터의 크기변형을 주던지이다.

```
행렬곱을 한다는 것은..

A = [[1,1],
	[1,0]]
	
B = [[3],
	[1]]
	
결과 = [[1*3, 1*1],
	   [1*3, 1*0]]
	   
# 1행1열의 원소에는 3배만큼의 효과를, 2행2열의 원소는 삭제를.. 이런 효과들을 합해서 평균해보니 이런 효과가 나오더라
	
# 행렬 곱이란 온갖 효과를 조합했을때 (평균했을때) 어떤 효과가 나오는 것이냐?
```

# 0704

## numpy - 이어서

__reshape(-1,n)?__

행은 몇개가 되어도 좋다. 대신에 열은 n개로 맞추어라!

> 이미지 데이터를 펼쳐 하나의 행으로 만들 것이다.

__tip__

데이터를 이루는 하나가 행이고, 그 데이터를 이루는 값들이 열이 된다.

### 전치행렬

행과 열을 바꾸는 것이다. 

행과 열만(matrix) 바꿀 수 있으며, 벡터는 안된다는 것을 뜻한다. 1차원이기 때문.

__벡터를 바꾸고 싶은 경우?__

```python
# vector의 shape은 (3,) 식으로 나오므로..
C = np.array([1,2,3,4,5])
C = C.reshape(1,5) 로 해주어야한다.
```

### numpy broadcast(편리성을 위해 확장)

행렬의 사칙연산을 편하게 해준다.

[[1,2],[3,4]] + 5 는 원래 오류이나, 앞의것에 대한 행에 맞추어 자동으로 계산해준다.

==> [[1,2],[3,4]] + [[5,5],[5,5]]  

> 행렬곱은 자동으로 되지않는다.

### iterator

처음부터 끝까지 어떤 데이터든 가져오는 것.

연속적으로 되어있는 데이터라면 처음부터 끝까지 가져올 수 있게해주는 도구이다.

행렬에 접근하기 쉽도록 index를 뽑아내준다!

```python
import numpy as np
    
A = np.array([[10,20,30,40],[50,60,70,80]])
    
it = np.nditer(A, flags = ["multi_index"], op_flags=['readwrite'])

while not it.finished:
    idx = it.multi_index
    # 어떻게 인덱스가 추출되는지 확인해보자
    print(idx)
    # 다음으로 넘어가준다.
    it.iternext()
```

## numpy의 유용한 함수들

_벡터나 행렬이 들어와야 한다는 것을 기억하자_

__np.loaded_data__()

```
loaded_data = np.loadtxt('./new/data-01.csv', delimiter = ',', dtype=np.float32)
# delimiter: 무엇으로 열이 구분되는지
```

__np.random.rand()__

```
random_num = np.random.rand(3,1)
# 0~1 사이의 임의의 값을 m행의 n열로 만들어낸다
```

기울기를 모르니 아무값이나 가져와서 적절한 기울기를 찾아가는데,

이 과정에서 임의의 값을 가져오는 것을 도와주는 것이 해당함수이다.

> 행렬곱시에 매우 편리하다. 행이나 열을 맞춰서 랜덤한 값으로 채울 수 있기 때문이다.

__np.sum(), np.exp(), np.log()__

- sum(): 모든 요소를 더해준다.
- exp(): 각각의 요소에 exp를 취해준다
- log(): 각각의 요소에 log를 취해준다.

__tip__

np의 method를 쓸 때에는 반드시 벡터나 행렬이어야한다.

__np.argmax(np.array, axis)__

> axis는 열(0)기준으로 할 것인지 행기준(1)으로 할 것인지이다. 디폴트는 행이다.

가장 큰값의 인덱스가 나온다.

arg를 통해 큰값이나 작은 값의 위치(idx)를 찾을 수 있다는 것은 다음을 의미한다.

예를 들어, 큰값이 나오는 인덱스가 있다는 건 무엇인가 있다는 것이므로, `detection` 에 유용하다는 것이다.

__오픈소스란?__

1. 소스가 공개되어있지만
2. 라이선스를 준수해야함

## matplotlib - 그래프를 그리기 위한 라이브러리

코드를 통해 살펴보자

```python
import matplotlib.pyplot as plt
import numpy as np

# 노트북 내부에 그림을 표시하기위한 코드
%matplotlib inline

# 100개의 데이터 랜덤생성 (0~1 사이)
x_data = np.random.rand(100)
y_data = np.random.rand(100)

print(y_data)

plt.title("scatter plot")
plt.grid()
# scatter, line, circle.. 
plt.scatter(x_data, y_data, color = 'b', marker = 'o')
# show를 하는 순간 화면에 내보낸다.
plt.show()
```

plt는 하나의 클래스로부터 나온 객체이다.

plt.title이라는 메소드를 통해 타이틀이라는 공간에 저장한다.

이렇게 전부 메소드를 통해 내부의 값에 접근해야한다는 것임!

__scatter__

자신이 가진 데이터 그대로를 찍어보자는 것이다.

빈번하게 쓰이는 그래프



다른 코드도 살펴보자.

```python
import matplotlib.pyplot as plt

%matplotlib inline

x_data = [ x for x in range(-5,5)]
y_data = [ y * y for y in range(-5,5)]

plt.title("line plot")
plt.grid()
plt.plot(x_data, y_data, color = "b")
plt.show()
```

__plt.plot__
점들을 선으로 연결해주는 method

# 0710 

## 지도학습과 비지도학습

__인공지능이란?__

인간이 하는 것을 기계가 대신해주는 것을 의미한다.

세탁기도 인공지능이라고 부를 수 있다.

__데이터 마이닝 vs 머신러닝__

데이터 마이닝: 분석해서 패턴을 뽑아내는 것.

머신러닝: 패턴을 뽑아내어 미지의 데이터로 미래를 예측해보는 것.

__Neural Network__

인간의 뇌 동작 방식을 모방한 것.

### 지도학습 vs 비지도학습 vs 강화학습

데이터를 기반으로 학습이 이루어지는데, 데이터에 따라 학습법이 달라진다.

#### 지도학습

입력 데이터와 정답데이터가 함께 있는 것이다.

> Regression, Classification

#### 비지도학습

입력 데이터가 있으나 정답데이터가 없는 것이다.

예측 결과가 확률로 나온다. (이 cluster에 속할 확률)

> Clustering

#### 강화학습

데이터 자체가 없어서 만들어 내어야 한다.

만들어 낸 데이터를 바탕으로 분석을 실시한다.

## 지도학습

입력은 X(행렬), 정답은 t(target, label)을 주로 사용한다.

### 회귀

연속적인 값을 예측하는 것이다.

트레이닝 데이터를 이용하여 연속적인 값을 예측한다.

0.5 0.7 등의 값이 가능하다.

> 모든 데이터는 평균으로 돌아가려는 경향이있다.

### 분류

주어진 값이 어떤 종류의 값인지 구별하는 것을 의미한다.

트레이닝 데이터를 이용하여 이산적인 값을 예측한다. 이거냐 저거냐를 의미하는 것!

0이나 1로 딱딱 나뉜다. == 이산적이다.

> 러닝: 입력데이터를 기반으로 기계가 학습을 한다. 

### 훈련 시

트레이닝 데이터와 테스트 데이터를 나누도록 하자. 모든 데이터를 트레이닝 데이터로만 사용한다면, 오버피팅의 문제가 발생할 수 있기 때문이다.

기계를 학습시킬 때 사용하는 데이터가 트레이닝 데이터이고, 기계 학습 완료 후 정확도 등을 파악하기 넣어보는 데이터가 테스트 데이터이다.

머신러닝의 문제점은 오버피팅이며, 이를 해결하기 위해 앙상블이나 트레이닝 데이터와 테스트 데이터 나누기 등 다양한 기법이 사용된다.

__오버피팅__

트레이닝 데이터에만 잘 동작하는 것.

__드랍아웃__(데이터의 연결을 임의로 끊는 것), __L2 Norm__등의 기법들이 더 존재하니 추후에 배우도록 하자.

# 0711

## 강화학습

강화학습을 할 때는 행동을 하는 주체(**에이전트**)와 활동하는 영역(**environment**)를 정의하는 것이 중요하다.

또한, 에이전트가 하는 행동(**action**)을 정의하고 올바른 행동을 했을 때 주어지는 보상(**reward**)를 확실히 하는 것이 좋다. 

## Regression & loss function

지도학습으로 정답이 있는 데이터를 INPUT으로 주어야한다. 이를 바탕으로 상관관계 등을 파악하고, 그 결과를 바탕으로 미지의 데이터가 주어졌을 때 그 결과를 **연속적인 숫자 값**으로 예측하는 것이다.

그렇다면 숫자의 패턴을 어떻게 찾아낼 것인가? 즉, **학습을 어떻게 할 것인가?**

y = Wx+b 일때, W와 b를 잘 조정하여 데이터에 근사한 직선을 그어주어야 하는데, 어떻게 적절한 W와 b를 찾을지에 대한 여러 방법을 알아보자.

### MSE (mean square error)

직선과 각 데이터의 거리(**오차**)를 제곱해서 평균을 내는 방법이다.

제곱을 하지 않으면 `-`와 `+` 의 상쇄효과로 에러가 존재하는데 0이 나올 수 있기 때문이다.

절댓값보다 더 유용한 이유는, 제곱했을 때 오차의 패널티를 더 제대로 줄 수 있기 때문이다. 

오차값에 가중치를 주는게 용이하기 때문!

### loss func

![1562827930826](C:\Users\olo51\AppData\Roaming\Typora\typora-user-images\1562827930826.png)

__우리의 목표?__

에러를 최소화시키는 W와 b를 찾는 것이 바로 우리의 목표이다.

### 경사하강법

미분을 이용하여 W와 b를 최소화 시키는 하나의 알고리즘!

하나의 시작점에서부터 계단을 내려가듯 이동하며 최소점을 찾기때문에, 데이터가 많으면 느려진다.

처음 시작점이 찍히면 그곳에서부터 내려가며, 시작점의 업데이트가 이루어지지 않기 때문에 local 최저점에 빠질 위험이 있다.

__경사하강법을 위한 조건__

convex function이어야 한다. 오목해야한다는 것이다.

# 0712

## W 와 b

### W

가중치(weight)를 의미한다.

정답을 만들어내기위해 필요한 입력의 개수만큼 존재해야한다.

### b

y절편으로, bias라고 부른다.

노드당 하나씩 들어간다.








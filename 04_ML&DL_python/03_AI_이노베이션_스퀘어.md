# 0701

## ML과 DM

DM은 상관관계 분석, 현재 데이터에 대한 분석이 주 목적. 

ML은 새로운 미지의 데이터까지 예측한다. 결과가 확률로 나온다.

> 데이터를 기반으로 미래의 값 예측

DL은 인간의 뇌를 본뜬 인공신경망이다. 

(인공지능(머신러닝(딥러닝)))의 포함관계이다. 

머신러닝의 알고리즘을 구현하는 것 중 하나가 바로 DL이다.

## ML

### Regression & Classfication

__회귀__
연속적인 값에 대한 미래 예측

__분류__

로지스틱 리그레션이라는 알고리즘이 사용된다. 

데이터들의 분포를 보고 분류해보는 것이다. 

### DL

좀 더 분류가 잘 되는게 없을까하여 등장한 것이다.

직선만으로 분류는 어렵기 때문이다.

인풋들을 모아 특정식을 거치게 해서,

어떠한 기준선(쓰레쓰홀드)을 넘으면 활성화하고 아니면 비활성화한다.

### 행렬 연산과 기본 수학 개념

__시그마__
x + y + z 라는건, 각각이 독립변수 라는 것이다.

종속변수라는건 원인으로 인해 결과가 100% 나오는 것.

"반드시" 라는 말이 들어가야한다. 

예외가 존재하면 독립변수임!

> 즉 시그마는 각각의 변수가 독립적이므로, 미분할 때 별개로 미분이 가능해진다. 각 항에 대한 연산이 상관 없다는 것이다.

개별 연산 수행 가능.

__곱하기__

로지스틱 리그레션 증명 시 한 번 쓰인다.

__행렬__

1. 산술연산
2. 행렬곱 (내적)

이미지 분석 시 이미지를 행렬로 표현가능하다.

> 2차원 행렬!

>  영상의 경우 2차원의 이미지들이 늘어져있는 것이므로 3차원 행렬.

이 행렬들을 일렬로 늘어트리게 되면 리그레션(ax+b)에 적용이 가능해진다.

## 파이썬

numpy로 생성되는 리스트는 배열이며, 행렬과 비슷하다.

python에는 데이터 조작을 편하게 하기위해 (-)인덱스가 존재한다. 

리스트에 다양한 자료형이 들어 갈 수 있다.

배열 원소의 자료형은 제한이없으며, 그 자료형에 맞게 딱딱 malloc이 된다.

__리턴값이 여러개인 경우?__

자바나 C는 여러개 넘겨 주는 것이 불가능해 각각 객체, 구조체를 만들어서 넘겨주면 된다. 

하지만 python은 리턴값을 여러개 전달 할 수 있다. 리턴되면 각 값들이 튜플로 들어온다.

### 리스트

```
c = []
c.append(100)
>> 배열도 하나의 클래스이다. append() 메소드를 사용하는 것.
```

머신러닝에서 판단결과가 true인지 false인지를 판단해서 append할 때 사용된다.

> 정확도 테스트 할 때 자주 쓰이는 것이다.

__슬라이싱__

범위를 지정하여 데이터를 뽑아내는 것이다. 

### 튜플

read only list이다. 한번 값을 정의하면 수정이 안된다.

list의 속성은 다 가지고 있다.

### 딕셔너리

orderedict이라는 객체를 사용하면 순서를 매길 수 있다.

__값의 참조?__

값의 참조는 전부 대괄호로 한다.

> `.`을 찍고 메소드를 사용한다는건, 객체(인스턴스)를 생성한것이다.

## 메소드

__.split(분리자)__

어떤 것을 기준으로 문자열을 나눌 것인가?

> 리턴은 리스트이다.

### tip 

regression과 classfication의 차이?

딥러닝의 원리? 뉴런의 원리 구현.

# 0702

## list comprehension

연속된 데이터 저장을 위해 리스트를 사용하는데,

그 내부에 for문이 도는 것

```
data = [x**2 for x in range(5)]
```

1. for문을 계산한다.
2. 계산한 것을 앞으로 보낸다.

## 함수

함수의 리턴값이 여러개인 경우 tuple의 형태로 날아온다.

### default parameter

함수 지정시 parameter에 기본값을 지정하는 것.

파라미터가 전달이 되지 않았을 때, 기본적으로 지정된 값을 사용하겠다는 의미이다.

파라미터는 오른쪽 끝에서부터 저장한다. 

파라미터를 받을 때 변수를 스택에 저장하는데, 차곡차곡 쌓아서 맨마지막 것을 꺼낸다.

그러므로 스택에는 오른쪽 끝에서 부터 채워나가는 것.

디폴트 파라미터를 주려면 오른쪽에서 부터 차곡차곡 넣어줘라.

### mutable / immutable parameter

1. mutable
   - 원래의 데이터에 변형이 일어나는 경우
   - 자의나 타의에 의해 변하는 것이다.
   - list, dict, numpy
   - 함수내에서 무언가를 그게 그대로 반영되어 변한다.
   - python에서 집합적인 형태의 데이터는 별도의 공간을 열지 않고 그대로 공유한다.
   - 함수에서 바꾸면 원본이 바뀜
2. immutable
   - 원래의 데이터에 변형이 일어나지 않음
   - 숫자, 문자, tuple
   - 함수내 들어온 것을 다른 공간에 저장함

## lamba

한 줄로 코드를 작성하는 일회용 함수.

```
lambda 파라미터:표현식
```

![1562051218222](C:\Users\olo51\AppData\Roaming\Typora\typora-user-images\1562051218222.png)

수학적 표현을 직관적으로 나타내기 위해 사용

## Class

새로운 데이터 타입이다.

1. 캡슐레이젼
   - 저장하는 모든 데이터를 클래스로 정의하겠다.
   - 클래스를 만든다는 것은 외부에서 접근하지 못하게 하겠다는 것
   - C++은 포인터가 있기때문에 이를 충족하지 못함.  
   - 아무리 보호하고 있어도 포인터가 있다면.. 삭제했을 때 죽어버릴수있다.
2. 인헤리턴스
   - 클래스 reuse
3. 폴리모피즘
   - 하나의 함수를 다양하게 사용하겠다.

---

클래스안의 메소드는 첫번째 인자로 self가 필수로 들어가야한다.

내부의 데이터를 접근하기 위해 필요하다는 것을 알려주는 것이다.

```
class Person:
	def __init__(self,name):
		# 내가 보호할 변수 정의
		self.name = name
	def get_name(self):
		return self.name
	def set_name(self, name):
		self.name = name
```

1. 보호할 변수 정의
2. 해당 데이터를 set하거나 get할 메소드 정의하기
3. 필요한 기능 추가하기
   - 저장한 데이터를 어떻게 이용하고 접근할 것인지 등이 해당된다.

> 메모리에 생성된 객체는 하나의 캡슐화가 된다. 
>
> 1. 포인터가 없어 아무도 지울 수 없으며,
> 2. set과 get을 통해서만 접근이 가능하다.

### plus

python은 편하게 사용하기위해 기본이 public이다.

원래는 외부에서 절대 접근 못하는데 기본이 public이라 바로 접근이 가능해진다.

이를 방지하고 컴파일러만이 부르게 하도록 하고 싶다면, **private** 설정을 해주어야 한다.

방법은 `__`를 붙여주면 된다.

```
def __init__(self, name):
	self.__name = name
	
def __work(self): # 함수에도 가능하다.
	print(name,"is working")
```


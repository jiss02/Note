# 1주차

## 기본환경 셋팅

프로젝트를 위해 장고를 설치할 때에는, 가상환경을 만들어 설치하자.

하나의 통안에 담는다고 생각하는 것이 좋다! 다른 프로젝트에는 영향을 미치지 않도록 하기 위함이다. 

> 여러 프로젝트를 수행하며 프로그램들이 꼬일 수 있거나 무엇을 설치했는지 헷갈릴 수 있기때문이다.

1. `python -m venv <name>`
2. `source <name>/Scripts/activate`
3. `deactivate` (가상환경 종료)
4. `pip install django`

## hello world 이론

Django는 어떤 과정을 거치며 데이터가 처리될까?

- 데이터가 여러 파일들 사이에 티키타카로 전송된다.

### 어디서 티키타카를 하는가?

__장고를 설치하고나서...__

먼저, 처음 장고를 시작하면 장고 프로젝트를 먼저 생성해줘야 할 것이다.

- `django-admin startproject <name>` 명령어를 실행하면 여러 프로젝트 폴더들이 생성된다.
- manage.py로 서버를 돌린다고 생각하면 된다.
- project이름으로 된 폴더안에는 `settings.py`, `url.py`가 들어간다.

`python manage.py runserver` 명령어로 서버를 구동한다.

__APP__

프로젝트의 구성 단위. 앱이 프로젝트의 작은 부분이며, 앱들이 모여 프로젝트를 이룬다.

`python manage.py starapp <app name>` 명령어로 app을 실행한다.

- 앱 이름으로 된 여러개의 폴더가 생긴다.

_앱 이름으로 생성된 여러개의 파일과 프로젝트 파일의 파일들끼리 **티키타카**를 진행한다!_

### 어떻게 티키타카를 하는가?

__templates 폴더__

일단 방법을 알기전에, 앱 폴더 안에 **templates**폴더를 만들어 줘야한다.

앱을 하나 만든다고해서, 프로젝트 폴더가 이를 알 수 는 없다.

따라서 사용자가 만든 앱을 알려줘야하는데, 프로젝트 폴더의 settings에 알려주면 된다.

이 폴더안에는 유저에게 보여질 화면(html)을 담으면 된다.

> 유저에게 보여지는 화면이라고 보면 편하다.

__views.py__

유저에게 보여질 화면이 언제, 어떻게 처리될지 알려주는 **함수**를 작성한다.

상황에 따라 다르게 처리되는 함수를 작성하는 것이다.

> 어떤 링크로 들어오면 이 html을 띄우세요~ 

__url.py__

내가 만든 html이 어떤 url을 입력했을 때 뜨게할지를 결정한다.

__정리__

1. 프로젝트 만들기
2. 프로젝트의 작은 부분인 앱만들기
3. 만들어진 앱을 연결하라고 `settings.py`에 알려주기 (프로젝트와 앱연결)
4. `템플릿폴더` 만들어 유저에게 보여줄 페이지 입력
5. `views.py` 에서 만들어진 html이 어떤 상황에서 어떻게 처리될지 알려주는 함수
6. `url.py`에서 해당 html파일과 url을 연결해준다.

## hello world 실습

> 포트번호: 8000 내컴퓨터를 의미한다.

__서버실행__

서버를 실행하고 나면 `db.sqlite3`이라는 파일이 생성되는데, 이는 db를 다루는 파일이다.

__프로젝트와 앱 연결하기__

프로젝트의 settings.py에 `myapp.apps.Myappconfig`를 입력해준다.

myapp의 apps파일에있는 MyappConfig 객체를 끌어와 달라!

> 앱이름.apps.앱이름Config

__views.py 작업하기__

```python
# 언제 어떤상황에서 사용할지 알려주자.
# 요청이 들어오면, home이라는 html을 내보내줘.
def home(request):
    return rendor(request, 'home.html')
```



__url.py에 작업하기__

```python
# url설계를 하자. 어떤 url이 들어올때 무엇을 실행할지.

from django.contrib import admin
from django.urls import path
# views.py에 쓰고자하는 기능이 들어있으니 임포트해주자.
import myapp.views

# 새로운 url넣어주자.
urlpatterns = [
    # /admin을 하면 저 url을 띄우세요!
    path('admin/', admin.site.urls),
    # 아무런 슬래쉬가 없는 사이트. 즉 홈이다.
    path('', myapp.views.home, name='home')
]
```

path (라우터, 실행시킬기능, 경로이름)

라우터에는 `/`뒤에 어떠한 조건이 붙었을때 무엇을 실행시킬지 알려주는 인자이다.

> 경로이름을 함수와 동일하게 짓도록하자. 그게 편하다.

# 1.5주차

## MTV 패턴

정보의 티키타카로 작동한다. == MTV 패턴.

- Model: DB를 다뤄주는 역할. 데이터를 뒤적뒤적한다.
- Template: 보여지는 화면
- View: 데이터가 어떤 상황에서 어떻게 처리되는지 모여있는 장소

각자 독립적으로 임무를 수행하며 장고 전체를 구동시킨다.

> 유지 보수가 편하다.

MVC 패턴을 차용한 방식이다. `C는 controller로 중간관리`를 하며, 여기서의 `View는 사용자에게 보여지는 부분`을 담당한다.

한마디로, MVC패턴의 view와 MTV패턴의 view는 다르다는 것이다. 헷갈리지 않도록 주의하자.

__tip__

html에서 장고 문법은 꺽쇠`{{ }}`안에! 

# 2주차

## wordcount 이론 _ 1

__복습__

장고 프로젝트를 만들고, 프로젝트를 이루는 구성단위는 앱이다. 

1. 프로젝트와 앱을 만들면 
2. 프로젝트의 `settings.py`에 앱이 만들어 진걸 알려주고
3. 앱에 `templates` 폴더를 만들어 사용할 html을 넣어줄 준비를 하고
4. `html`을 넣어준뒤
5. 템플릿이 어떤 상황에서 어떻게 표시될지를 앱의 `views.py`에서 함수를 정의해주고
6. 프로젝트의 `url.py`에 들어가서 해당 템플릿이 표시될 url도 만들어 주면 된다.

## 프로젝트 스케치

1. 어떤 정보를 보여줄지 틀을 잡자.
2. 우리가 만들어야할 HTML 파일이 무엇이고 몇개인지 정하자.
3. 각각의 html이 무슨기능을 할지 서술해보자. 
4. 정보를 어떤 상황에서 어떻게 알려줄지 처리하는 함수를 정리해보자.
5. 그리고 각 페이지에 맞게 url을 구상해주면 간단한 전반적인 스케치 과정은 끝난다.

## 템플릿 언어

HTML 안에 쓰는 장고 제공언어. 장고 문법을 html에서 사용할 수 있다!

### 템플릿 변수

`{{ python_var }}` 해당 파이썬 변수를 html 파일에 담아 출력해라!

### 템플릿 필터

템플릿 변수에 추가적인 속성 및 기능 제공

`{{ python_var | filter }}`  의 형태로 사용한다.

__예시__

`{{ python_var | lower }}`  :  변수를 소문자로 출력하라!

### 템플릿 태그

html에서 파이썬 문법사용, url 생성등의 기능을 제공한다.

`{% tag %}...태그내용...{% endtag %}` 의 형태로, 

마치 하나의 태그처럼 닫는 태그도 써주어야 한다.

__url 생성__

`{%  url 'url_name(path name)' %}` 의 형태로,

url 태그에 해당하는 위치에 url을 생성해준다.

### 템플릿 상속

## wordcount 실습

### render 함수에 대하여

`render(request, 'main.html', ...)` 의 형태로 첫번째 인자는 주로 리퀘스트(요청)가 들어오며,

두번째 인자로는 어떤 템플릿을 띠워줄 것인지 지정해준다.

세번째 인자로는 사전형 자료, 객체를 담아 변수를 전달해 줄 수 있다. 

# 3주차

__학습목표__

Model 에 데이터를 어떻게 담을 것인가

Model의 데이터를 어떻게 view로 넘길 것인가

그것을 어떻게 화면에 띄울 것인가

## model & admin 이론

### Model

데이터베이스를 다뤄준다.

우리는 `model.py`에 우리가 원하는, 가공하고자 하는 데이터를

종류가 무엇이고 어떤식으로 데이터가 처리되길 원하는지 **class**의 형태로 알려주면된다.

우리가 사용하고자 하는 데이터의 틀(형식)을 잡아 정의해주면 된다.

> 일기라고 치면 >>짧은글(제목), 시간, 긴글<< 의 틀을 가질 것이다.

```
class 블로그글:
	짧은글
	시간
	긴글
```

`model.py`는 데이터를 만드는 공장이고,

Class는 객체를 편하게 찍어내기위한 틀이다.

__팁__

데이터 베이스는 장고와 별개이며, setting.py에서 등록해줄 수 있다.



### 데이터베이스와 장고

장고는 데이터 베이스에게 model.py안에 어떻게 생긴 데이터를 처리하기로 했는지 알려주면 된다!

그 명령어는,

```
# 데이터베이스에게 모델을 만들거라고 알려주는 과정
$ python manage.py makemigrations
# 실제로 데이터베이스에 우리가 만든 것을 적용하는 과정
$ python manage.py migrate
```

이다.



### 어드민 계정 생성

위의 과정을 마친 후, 어드민 계정을 생성해 주어야 하는데, 

`$ python manage.py createsuperuser` 명령어를 통해 생성이 가능하다.

그 후, `admin.py`에 어떠한 데이터를 처리할 것인지를 등록하자.



### 정리

1. Models.py 안에 어떤 종류의 데이터를 처리할지 Class로 정의
2. DB에게 알아듣게끔 두개의 명령어 입력하기
3. admin 계정 만들기.
4. admin.py에 활용할 데이터 등록

> 데이터베이스에 어떻게 생긴 데이터를 집어넣을지 정의하고, 거기에 admin권한으로 데이터를 집어 넣는다.

## model&admin 실습

데이터베이스에 있는 자료를 template에 띄우고 싶다면 어떻게 해야할까?

바로 띄울 수는 없을 것이다.

그러므로 중간 역할을 하는 view를 거쳐야 한다!

어떤 데이터가, 어떻게 처리될지를 함수로 정의해주자.

아래와 같은 함수를 정의했다고 해보자. 

Blog는 models.py에서 만든 무언가의 객체틀이라고 보면 된다.

```python
def home(request):
    # 블로그 안에있는 객체를 담아주자.
    # 모델로 부터 객체 목록을 전달받는 것이다.
    blogs = Blog.objects # 쿼리셋
    return render(request, 'home.html', {'blogs':blogs})
```

__쿼리셋__

모델로부터 전달받은 객체 목록을 의미한다.

쿼리셋을 기능들을 처리하거나 정렬하도록 해주는 것이 **메소드**이다.

### 쿼리셋 메소드

데이터를 늘 전체만 찍어보는 것이아니라, 

일부만 찍어보고 싶을 수도 있고 정렬을 해보고 싶을 수 도 있을 것이다. 

이럴 때 사용하는 것이 쿼리셋이다!

한마디로 쿼리셋 메소드는, **쿼리셋을 활용할 수 있게 해주는 것**이다.

#### 활용 방법

`모델이름.쿼리셋`.메소드 == `model.objects.method`

# 4주차

## pk, path converter, get_object_or_404

### what to do?

1. 글자수 제한
2. ...more 링크
3. detail 페이지로 이동하기

만약 우리가 게시글을 자세히 보고싶어 더보기 버튼을 눌렀다고 하자.

그렇다면 detail 페이지로 이동하게 될텐데,

게시글의 수만큼 이에 대응하는 detail 페이지를 만들 수 있을까?



만약 1억개의 게시글이 있다면, 1억개의 디테일 페이지가 있을텐데..

만약 디테일 페이지를 수정해야할 일이 생긴다면.. 정말 끔찍할 것이다.



이 문제를 해결하기위해 객체마다 번호를 부여하고,

하나의 디테일 페이지에 그 번호에 해당하는 객체를 넣어 띄워주는 방식을 취할 수 있다.

하나의 디테일 페이지라는 틀에, 알맞은 객체를 그때그때 갈아끼워주는 것이다.



x번째 객체를 사용자가 요청하면, 우리는 그에 해당하는 객체를 보여줘야한다.



#### url 설계

우선 사용자가 요청과 함께 전달하는 객체의 번호를 받을 수 있도록 url을 설계하자.

`path('detail/<int:detail_id>', view.py의 함수, url 이름)`

`detail/객체번호` 의 형태로 url을 받은 것인데, 형태가 좀 이상하다.

이가 바로 path converter이다.



#### path converter

`<type:변수이름>`의 형태를 가진다! 

위에서의 변수이름은 detail_id로, 

이는 views.py의 함수에 인자를 넘겨줄 때 어떤 이름으로 넘겨줄 것인지를 적어주는 것이다.

그러므로 뷰의 함수가 인자를 전달받을때, 

request인자와 함께 detail_id를 인자로 받아야 할 것이다.

# pk, path converter, get_object_or_404 - 2

이용자가 x번 객체를 가져다줘! 라고 요청을한다면,

url을 타고 우리의 장고에 들어오게 될 것이다.



우선 path converter를 통해 url을 설계해주자.

어떤 형태의 데이터를 url로 받을지 정의해주고,

함수에 인자를 어떤이름으로 넘겨줄건지를 정의해주면된다.



(이클래스안에서 가져올건데, 몇번째 값을 가져와줘)

